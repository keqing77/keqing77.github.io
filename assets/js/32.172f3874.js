(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{522:function(t,e,a){"use strict";a.r(e);var s=a(13),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue2面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2面试题"}},[t._v("#")]),t._v(" Vue2面试题")]),t._v(" "),a("h3",{attrs:{id:"vue目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue目录结构"}},[t._v("#")]),t._v(" Vue目录结构")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("目录名")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("作用")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("assets")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("放静态资源")])]),t._v(" "),a("tr",[a("td",[t._v("components")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是放组件")])]),t._v(" "),a("tr",[a("td",[t._v("app.vue")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("根组件")])]),t._v(" "),a("tr",[a("td",[t._v("main.js")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("入口文件")])]),t._v(" "),a("tr",[a("td",[t._v("router(可选)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("路由")])]),t._v(" "),a("tr",[a("td",[t._v("store(可选)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("状态管理")])])])]),t._v(" "),a("h3",{attrs:{id:"什么是spa-单页面应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是spa-单页面应用"}},[t._v("#")]),t._v(" 什么是SPA(单页面应用)")]),t._v(" "),a("p",[t._v("SPA(Single-Page-Application),单页面应用，就是在页面初始化时，一同加载HTML、CSS、JavaScript，一旦页面加载完成，SPA不会因为用户操作而进行页面跳转和重新加载(例如a标签跳转)，而是采用路由进行组件间的切换，实现html内容的变化。可以给客户更好的用户体验，内容更改无需重新加载页面。")]),t._v(" "),a("p",[a("strong",[t._v("优点:")]),t._v(" SPA相较于SSR对服务器的压力更小"),a("br"),t._v(" "),a("strong",[t._v("缺点:")])]),t._v(" "),a("ul",[a("li",[t._v("是首次加载时间过长")]),t._v(" "),a("li",[t._v("不利于SEO")]),t._v(" "),a("li",[t._v("不支持浏览器的前进后退(这个问题被路由解决了)")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("本站就是SPA")]),t._v(" "),a("p",[t._v("你可以切换页面并观察url以及网络的变化，url变化但并没有重新发起http请求，这就是SPA，一开始就全部加载完成了")])]),t._v(" "),a("h3",{attrs:{id:"什么是ssr-服务端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是ssr-服务端渲染"}},[t._v("#")]),t._v(" 什么是SSR(服务端渲染)")]),t._v(" "),a("p",[t._v("顾名思义是将渲染的工作放在 Server 端进行。服务器渲染"),a("code",[t._v("完整")]),t._v("的HTML后返回给客户端。")]),t._v(" "),a("p",[t._v("而与之对应的是 CSR ，客户端渲染，也就是目前 Web 应用中主流的渲染模式，一般由 Server 端返回的初始 HTML 页面，然后再由 JS 去异步加载数据，然后完成页面的渲染。")]),t._v(" "),a("h3",{attrs:{id:"完美回答之生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#完美回答之生命周期"}},[t._v("#")]),t._v(" 完美回答之生命周期")]),t._v(" "),a("p",[t._v("生命周期就是Vue实例从创建到销毁的过程，过程分为八个钩子，分别是创建前后、挂载前后、更新前后、销毁前后。即指从创建、初始化数据、编译模板、挂载到DOM上和渲染、更新到渲染、销毁的一系列过程。")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("生命周期中比较重要的钩子")]),t._v(" "),a("p",[t._v("created()，这时候数据初始化完成，可以在这里发ajax请求等等。也就是created在组件实例一旦创建完成后就立即调用created()方法，这时候页面dom节点还没生成。")]),t._v(" "),a("p",[t._v("mounted()，是在dom节点渲染完成之后立刻调用的，所以可以获取访问数据和dom元素。")]),t._v(" "),a("p",[t._v("beforeDestory()销毁前需要清除定时器清除缓存")]),t._v(" "),a("p",[t._v("还有Keep-alive带来的三个额外钩子")])]),t._v(" "),a("h3",{attrs:{id:"vue中的-ref-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中的-ref-是什么"}},[t._v("#")]),t._v(" vue中的 ref 是什么？")]),t._v(" "),a("blockquote",[a("p",[t._v("ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。")])]),t._v(" "),a("ul",[a("li",[t._v("如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；")]),t._v(" "),a("li",[t._v("如果用在子组件上，引用就指向组件实例。")])]),t._v(" "),a("h3",{attrs:{id:"什么是-nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-nexttick"}},[t._v("#")]),t._v(" 什么是$nextTick?")]),t._v(" "),a("blockquote",[a("p",[t._v("一次完整的DOM更新称为Tick，nextTick也就是在下次DOM更新循环j结束之后执行延迟回调，常用于修改数据后获取更新后的DOM。")])]),t._v(" "),a("p",[t._v("其实就是运用异步锁的的概念，保证同一时刻任务队列只有一个flushCallbacks，当pending为false的时候，表示浏览器任务队列中没有flushCallbacks函数，当pending为true的时候，表示浏览器任务队列中已经放入flushCallbacks，待执行flushCallbacks函数时，pending为被再次置位false，表示下一个flushCallbacks可进入任务队列，环境能力检测选择可选中效率最高的(宏任务/微任务)进行包装执行，保证是在同步代码都执行完成后，再去执行修改DOM等操作，flushcallbacks先拷贝再清空，为了防止nextTick嵌套mextTick导致循环不结束")]),t._v(" "),a("p",[t._v("源码: vue/src/core/util/next-tick.js")]),t._v(" "),a("p",[t._v("Tick是一次数据渲染的周期，nextTick就是指渲染后执行")]),t._v(" "),a("ul",[a("li",[t._v("*"),a("code",[t._v("$nextTick")]),t._v("是什么？vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。"),a("code",[t._v("$nextTick")]),t._v(" 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM")])]),t._v(" "),a("h3",{attrs:{id:"vue中key的作用-或者v-for为什么一定要加key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中key的作用-或者v-for为什么一定要加key"}},[t._v("#")]),t._v(" Vue中key的作用，或者V-for为什么一定要加key？")]),t._v(" "),a("p",[t._v("key是Vue中Vnode的唯一标记，diff算法中，sameVnode和updateChildren中就使用了key。sameVnode用来判断是否为同一节点，常见的业务常见是一个列表，若key值是列表索引，在新增或删除的情况下就会存在"),a("strong",[t._v("就地复用")]),t._v("的问题(就是复用了上一个在当前位置元素的状态)。所以key值的唯一确保diff更准确。")]),t._v(" "),a("p",[t._v("updateChildren保证新开老开是同一节点，新开老结是同一节点，老开新结是同一节点，老结新开是同一节点。如果都未匹配，就需要依赖老节点的key和索引创建关系映射表，再用新节点的key去关系映射表，再用新节点的key去关系映射表，去寻找索引进行更新。这保证diff算法快速而准确")]),t._v(" "),a("h3",{attrs:{id:"v-mode双向绑定是如何实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-mode双向绑定是如何实现的"}},[t._v("#")]),t._v(" V-mode双向绑定是如何实现的")]),t._v(" "),a("p",[t._v("v-model指令用于实现input、select等表单元素的双向绑定，实际上是@input和value的语法糖。")]),t._v(" "),a("ul",[a("li",[t._v("原生input元素若是text/textarea类型，使用value属性和input事件。")]),t._v(" "),a("li",[t._v("原生input元素若是radio/checkbox类型，使用checked属性和change事件。")]),t._v(" "),a("li",[t._v("原生select元素，使用value属性和change事件。")])]),t._v(" "),a("p",[t._v("input元素上使用v-mode等价于")]),t._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("input")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":value")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("messgae"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("@input")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("message = $event.target.value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h3",{attrs:{id:"为什么说vue是单向数据流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么说vue是单向数据流"}},[t._v("#")]),t._v(" 为什么说Vue是单向数据流？")]),t._v(" "),a("p",[t._v("子组件无权修改父组件传递的数据，防止子组件意外变更父组件的状态，导致数据流向难以理解，所以说Vue是单向数据流。"),a("br")]),t._v(" "),a("p",[t._v("参考父子组件通信之"),a("strong",[t._v("子组件传值给父组件")]),t._v("，子组件无法直接传值给父组件，需要触发父组件的事件去让父组件自己去修改值的变化。")]),t._v(" "),a("h3",{attrs:{id:"组件中的data为什么是一个函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件中的data为什么是一个函数"}},[t._v("#")]),t._v(" 组件中的data为什么是一个函数？")]),t._v(" "),a("p",[t._v("对象在栈中存储的都是地址，函数的作用就是属性私有化，保证组件修改自身时不会影响其他复用组件。如果是对象的话，一个组件修改data的值，其他复用组件都会跟着修改，不方便数据维护。")]),t._v(" "),a("h3",{attrs:{id:"v-if和v-show有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-show有什么区别"}},[t._v("#")]),t._v(" v-if和v-show有什么区别？")]),t._v(" "),a("p",[t._v("两者都是控制元素显示和隐藏，v-if是控制元素本身的增加或者删除，而v-show控制的是元素的CSS属性(display:none)。")]),t._v(" "),a("p",[t._v("也就是说 ，v-if控制的是整个DOM节点的渲染与否，DOM节点的切换会有更大的性能消耗(重排reflow)，如果频繁切换的话使用v-show，一次切换的话就可以考虑v-if。")]),t._v(" "),a("p",[t._v("还有一个区别就是v-show由flase变为true的时候不会触发组件的生命周期，而v-if由false变为true的时候则会触发组件的beforeCreate、created、beforeMount、mounted")]),t._v(" "),a("h3",{attrs:{id:"v-if和v-for一起使用会有什么问题-如何解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-for一起使用会有什么问题-如何解决"}},[t._v("#")]),t._v(" v-if和v-for一起使用会有什么问题？如何解决？")]),t._v(" "),a("p",[t._v("性能开销变大，每次渲染都要先循环再进行条件判断，其次是优先级的问题，Vue2中v-for优先级比v-if高，Vue3中v-if比v-for高。")]),t._v(" "),a("p",[t._v("解决的办法之一是采用计算属性替代，先在计算属性里面对数据做一个筛选，然后直接for循环筛选后的数据，就不需要if进行判断了。")]),t._v(" "),a("h3",{attrs:{id:"computed和watch有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch有什么区别"}},[t._v("#")]),t._v(" computed和watch有什么区别")]),t._v(" "),a("p",[t._v("computed和watch本质都是通过实例化Watcher实现，最大区别就是使用场景不同。")]),t._v(" "),a("p",[t._v("computed也就是计算属性，依赖其他值且值具备缓存的特性，只有它依赖的值发送发生改变，下一次获取的值才会重新计算，适用于复杂的数值计算并且依赖于其他属性时，就可以利用缓存特性，避免每次获取值都需要重新计算。")]),t._v(" "),a("p",[t._v("watch侦听器，监听属性值的变化，每当属性值发送变化，都会执行相应的回调函数。适用于数据变化时执行异步或者开销比较大的操作")]),t._v(" "),a("h3",{attrs:{id:"vue的响应式原理-不是v-model-那个是-input和value语法糖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的响应式原理-不是v-model-那个是-input和value语法糖"}},[t._v("#")]),t._v(" Vue的响应式原理(不是V-model，那个是@input和value语法糖）")]),t._v(" "),a("p",[t._v("三个步骤")]),t._v(" "),a("ul",[a("li",[t._v("数据劫持")]),t._v(" "),a("li",[t._v("收集依赖")]),t._v(" "),a("li",[t._v("派发更新")])]),t._v(" "),a("p",[t._v("数据分为两类，数组和对象。")]),t._v(" "),a("p",[t._v("当遍历对象的时候，通过Object.defineProperty为每个属性添加getter和setter进行数据劫持，getter函数用于在数据读取时进行收集依赖，在对应的dep中存储所有的watcher，setter则是在数据更新后通知所有的watcher进行更新")]),t._v(" "),a("p",[t._v("当遍历数组的时候，用数组增强的方式，覆盖原属性上默认的数组方法，保证在新增或删除数据时，通过dep通知所有的watcher进行更新")]),t._v(" "),a("p",[t._v("可以运用观察者模式，当一个对象被修改时会自动通知依赖它的对象")]),t._v(" "),a("p",[t._v("或者发布-订阅模式，更适合响应式")]),t._v(" "),a("blockquote",[a("p",[t._v("响应式更新对象的源码下图")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" defineReactive"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    xxxx快了快了"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("blockquote",[a("p",[t._v("响应式更新数组源码如下图")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" defineReactive"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    xxxx快了快了"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("blockquote",[a("p",[t._v("观察者模式和发布订阅模式")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" defineReactive"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    xxxx快了快了"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("h3",{attrs:{id:"完美回答之vue2响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#完美回答之vue2响应式原理"}},[t._v("#")]),t._v(" 完美回答之Vue2响应式原理")]),t._v(" "),a("p",[t._v("1.vue会遍历此data中对象的所有属性")]),t._v(" "),a("p",[t._v("2.并使用Object.defineProperty把这些属性全部转为getter/setter")]),t._v(" "),a("p",[t._v("3.每个组件实例都有watcher对象")]),t._v(" "),a("p",[t._v("4.它会在组件渲染的过程中吧属性记录为依赖")]),t._v(" "),a("p",[t._v("5.之后当依赖项的setter被调用时，会通知watcher重新计算，从而使它关联的组件得以更新")]),t._v(" "),a("p",[t._v("三个最重要的对象")]),t._v(" "),a("p",[t._v("Observer、Watcher、Dep")]),t._v(" "),a("p",[t._v("Observer对象: vue中的数据对象在初始化过程中转换为Observer对象")]),t._v(" "),a("p",[t._v("Watcher对象: 将模板和Observer对象结合在一起生成watcher实例，Watcher是订阅者中的订阅者。")]),t._v(" "),a("p",[t._v("Dep对象: Watcher对象和Observer对象之间纽带，每一个Observer都有一个Dep实例，用来存储订阅者Watcher")]),t._v(" "),a("p",[t._v("当属性变化会执行主体对象Observer的dep.notify()方法，这个方法会遍历订阅者Watcher列表向其发送信息，Watcher会执行run方法去更新视图。模板编译过程中的指令和数据绑定都会生成watcher实例，实例中的watch属性也会生成Watcher实例")]),t._v(" "),a("p",[t._v("1、在生命周期的initState方法中将data，prop，method,computed, watch中的数据劫持，通过observe方法与Object.defineProperty方法将相关对象转为换Observer对象。\n2、然后在initRender方法中解析模板，通过Watcher对象，Dep对象与观察者模式将模板中的指令与对象的数据建立依赖关系，使用全局对象Dep.target实现依赖收集。\n3、当数据变化时，setter被调用，触发Object.defineProperty方法中的dep.notify方法，遍历该数据依赖列表，执行器update方法通知Watcher进行视图更新。\nvue是无法检测到对象属性的添加和删除，但是可以使用全局Vue.set方法（或vm.$set实例方法)。vue无法检测利用索引设置数组，但是可以使用全局Vue.set方法（或vm.$set实例方法)。\n无法检测直接修改数组长度，但是可以使用splice")]),t._v(" "),a("div",{staticClass:"language-tsx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-tsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//[empty,2,3,4]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//[2,3,4]")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("h3",{attrs:{id:"vue-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[t._v("#")]),t._v(" Vue-Router")]),t._v(" "),a("p",[t._v("(路由传参、动态路由、路由守卫钩子、缓存路由)")]),t._v(" "),a("blockquote",[a("p",[t._v("vue路由传参数")])]),t._v(" "),a("ul",[a("li",[t._v("1.使用query方法传入的参数使用this.$route.query接受")]),t._v(" "),a("li",[t._v("2.使用params方式传入的参数使用this.$route.params接受")])]),t._v(" "),a("blockquote",[a("p",[t._v("hash模式 和 history模式")])]),t._v(" "),a("p",[t._v("hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；\n特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。\nhash 模式下:仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。\nhistory模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。\nhistory 模式:前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”")]),t._v(" "),a("p",[a("strong",[t._v("$route和$router的区别？")])]),t._v(" "),a("p",[t._v("$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。$router是'路由实例'对象包括了路由的跳转方法，钩子函数等。")]),t._v(" "),a("h3",{attrs:{id:"vue-router如何响应路由参数的变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router如何响应路由参数的变化"}},[t._v("#")]),t._v(" vue-router如何响应路由参数的变化")]),t._v(" "),a("h3",{attrs:{id:"问题-为什么要响应参数变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-为什么要响应参数变化"}},[t._v("#")]),t._v(" 问题：为什么要响应参数变化？")]),t._v(" "),a("ul",[a("li",[t._v("切换路由，路由参数发生了变化，但是页面数据并未及时更新，需要强制刷新后才会变化。")]),t._v(" "),a("li",[t._v("不同路由渲染相同的组件时（组件复用比销毁重新创建效率要高），在切换路由后，当前组件下的生命周期函数不会再被调用。")])]),t._v(" "),a("p",[t._v("解决方案：")]),t._v(" "),a("ol",[a("li",[t._v("使用 watch 监听")])]),t._v(" "),a("p",[a("code",[t._v('watch: { $route(to, from){ if(to != from) { console.log("监听到路由变化，做出相应的处理"); } } }')])]),t._v(" "),a("ol",[a("li",[t._v("向 router-view 组件中添加 key"),a("code",[t._v('<router-view :key="$route.fullPath"></router-view>')])])]),t._v(" "),a("blockquote",[a("p",[t._v("$route.fullPath 是完成后解析的URL，包含其查询参数信息和hash完整路径")])]),t._v(" "),a("h3",{attrs:{id:"vue-router有哪几种导航钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router有哪几种导航钩子"}},[t._v("#")]),t._v(" vue-router有哪几种导航钩子")]),t._v(" "),a("p",[t._v("3种，全局的、组件的、单个路由独享的")]),t._v(" "),a("p",[t._v("1：全局守卫：beforeEach,afterEach")]),t._v(" "),a("p",[t._v("2:路由独享守卫：beforeEnter")]),t._v(" "),a("p",[t._v("3:组件级别的守卫beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave")]),t._v(" "),a("p",[t._v("他们执行顺序：全局》路由》组件")]),t._v(" "),a("p",[t._v("除了afterEach全局后置外，其他的守卫中务必要调用next(),否则无法完成导航")]),t._v(" "),a("p",[t._v("还有注意全局前置守卫可以用来进行拦截，（登录拦截）")]),t._v(" "),a("h3",{attrs:{id:"vue-router路由有几种模式-说说它们的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router路由有几种模式-说说它们的区别"}},[t._v("#")]),t._v(" vue-router路由有几种模式？说说它们的区别？")]),t._v(" "),a("p",[t._v("hash模式：")]),t._v(" "),a("p",[t._v("1.url路径会出现“#”号字符")]),t._v(" "),a("p",[t._v("2.hash值不包括在Http请求中，它是交由前端路由处理，所以改变hash值时不会刷新页面，也不会向服务器发送请求")]),t._v(" "),a("p",[t._v("3.hash值的改变会触发hashchange事件")]),t._v(" "),a("p",[t._v("history模式：")]),t._v(" "),a("p",[t._v("1.整个地址重新加载，可以保存历史记录，方便前进后退")]),t._v(" "),a("p",[t._v("2.依赖H5 API和后台配置，没有后台配置的话，页面刷新时会出现404")]),t._v(" "),a("h3",{attrs:{id:"vue-router怎么配置404页面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router怎么配置404页面"}},[t._v("#")]),t._v(" vue-router怎么配置404页面")]),t._v(" "),a("div",{staticClass:"language-tsx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-tsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'*'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'404'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    component"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'组件404'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n需注意：将改路由配置放到所有路由的配置信息的最后，否则会其他路由path匹配造成影响。\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])])])}),[],!1,null,null,null);e.default=r.exports}}]);