(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{596:function(t,_,o){"use strict";o.r(_);var r=o(13),e=Object(r.a)({},(function(){var t=this,_=t.$createElement,o=t._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"原型和原型链"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[t._v("#")]),t._v(" 原型和原型链")]),t._v(" "),o("h1",{attrs:{id:"原型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),o("p",[t._v("每个对象拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性，这些属性和方法定义在对象的构造器函数的 prototype 属性上，而非对象实例本身。")]),t._v(" "),o("h1",{attrs:{id:"原型链"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),o("p",[t._v("每个对象拥有一个原型对象，通过 "),o("strong",[t._v("proto")]),t._v(" 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法")]),t._v(" "),o("hr"),t._v(" "),o("p",[t._v("对象的属性值不是存放在对象内部的，存放仅仅是属性的引用")]),t._v(" "),o("p",[t._v("prototype ->  函数的一个属性: 是一个对象{}  所以也叫原型对象 或者显式原型\n"),o("strong",[t._v("proto")]),t._v(" -> 对象Object的一个属性: 也是一个对象{}   隐式原型\n对象的__proto__保存着该对象的构造函数的prototype")]),t._v(" "),o("p",[o("strong",[o("code",[t._v("Object.getPrototypeOf()")])]),t._v(" 方法返回指定对象的原型（内部"),o("code",[t._v("[[Prototype]]")]),t._v("属性的值）。")]),t._v(" "),o("p",[t._v("实际上Function的prototype是一个内置函数，一切函数都派生自这个内置函数，这个内置函数是一个函数工厂。")]),t._v(" "),o("p",[t._v("在Javascript中,每一个函数实际上都是一个函数对象。")]),t._v(" "),o("p",[t._v("Function和Object，既是函数，因为都可以Function()或者Object()这样的方式执行，又是对象，因为可以Function.a = 'a',Object.a = 'a'这样赋值。")]),t._v(" "),o("div",{staticClass:"language-jsx line-numbers-mode"},[o("pre",{pre:!0,attrs:{class:"language-jsx"}},[o("code",[t._v("\n")])]),t._v(" "),o("div",{staticClass:"line-numbers-wrapper"},[o("span",{staticClass:"line-number"},[t._v("1")]),o("br")])]),o("h1",{attrs:{id:"原型-2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原型-2"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),o("p",[t._v("每个 JS 对象都有 "),o("code",[t._v("__proto__")]),t._v(" 属性，可以通过__proto__找到自己的原型，原型也是一个对象。这个对象上有许多函数和方法，因此可以使用。同时这个原型对象还有一个constructor属性，指向这个构造函数本身。")]),t._v(" "),o("blockquote",[o("p",[t._v("注意: "),o("strong",[t._v("proto")]),t._v("这个属性是浏览器实现的，并不是JS自带的，是浏览器早期为了让我们访问到内部属性 [[prototype]] 来实现的一个东西。")])]),t._v(" "),o("p",[t._v("prototype 属性")]),t._v(" "),o("p",[t._v("constructor 属性")]),t._v(" "),o("p",[t._v("特点：JS对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变")]),t._v(" "),o("h1",{attrs:{id:"原型链-2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原型链-2"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),o("p",[t._v("每个对象拥有一个"),o("strong",[t._v("原型对象")]),t._v("，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为"),o("strong",[t._v("原型链 (prototype chain)")]),t._v("，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。")]),t._v(" "),o("p",[t._v("当一个对象调用某个方法或者属性的时候，先在自身查找，如果找到就调用，如果没有就顺着__proto__到原型对象中查找，如果还没有就继续去原型的原型中查找，一直到null，这样形成一条链叫做原型链。如果还没有找到就返回undefined")]),t._v(" "),o("h3",{attrs:{id:"经典图"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#经典图"}},[t._v("#")]),t._v(" 经典图")]),t._v(" "),o("p",[o("a",{attrs:{href:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7681c7ae-5560-40d9-8573-a6a9fd6761e2/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%9B%BE.webp",target:"_blank",rel:"noopener noreferrer"}},[t._v("原型链图.webp"),o("OutboundLink")],1)]),t._v(" "),o("ul",[o("li",[o("code",[t._v("Object")]),t._v(" 是所有对象的顶级原型，所有对象都可以通过 "),o("code",[t._v("__proto__")]),t._v(" 找到它")]),t._v(" "),o("li",[o("code",[t._v("Function")]),t._v(" 是所有函数的顶级原型，所有函数都可以通过 "),o("code",[t._v("__proto__")]),t._v(" 找到它")]),t._v(" "),o("li",[t._v("函数的 "),o("code",[t._v("prototype")]),t._v(" 是一个对象")]),t._v(" "),o("li",[t._v("对象的 "),o("code",[t._v("__proto__")]),t._v(" 属性指向原型， "),o("code",[t._v("__proto__")]),t._v(" 将对象和原型连接起来组成了原型")])])])}),[],!1,null,null,null);_.default=e.exports}}]);