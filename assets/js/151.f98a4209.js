(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{754:function(t,e,l){"use strict";l.r(e);var s=l(14),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"usecallback"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[t._v("#")]),t._v(" useCallback")]),t._v(" "),l("div",{staticClass:"theorem"},[l("p",{staticClass:"title"},[t._v("useMemo 和 useCallback 原理一样")]),l("blockquote",[l("p",[t._v("useMemo 和 useCallback 接收的参数都是一样,第一个参数为回调 第二个参数为要依赖的数据")])]),t._v(" "),l("p",[t._v("作用主要是 数据缓存，当缓存的状态数据，发生改变时才会刷新数据，如果缓存的状态数据没有发生改变。\n则不会刷新缓存区域，从而达到部分区域缓存的效果，减少重复渲染次数，提高应用性能")]),t._v(" "),l("blockquote",[l("p",[t._v("共同作用：")])]),t._v(" "),l("ol",[l("li",[t._v("依赖数据 发生变化, 才会重新计算结果，也就是起到缓存的作用。")])]),t._v(" "),l("blockquote",[l("p",[t._v("两者区别：")])]),t._v(" "),l("ol",[l("li",[l("p",[t._v("useMemo 计算结果是 return 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要 计算的状态")])]),t._v(" "),l("li",[l("p",[t._v("useCallback 计算结果是 函数, 主要用于 缓存函数，\n应用场景如: 需要缓存的函数，因为函数式组件每次任何一个 state 的变化 整个组件 都会被重新刷新，\n一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费。")])])])]),l("div",{staticClass:"custom-block danger"},[l("p",{staticClass:"custom-block-title"},[t._v("不要滥用useCallback")]),t._v(" "),l("ul",[l("li",[t._v("会造成性能浪费，react中减少render就能提高性能，\n所以这个仅仅只针对缓存能减少重复渲染时使用和缓存计算结果。")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);