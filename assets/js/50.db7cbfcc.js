(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{631:function(t,s,a){"use strict";a.r(s);var e=a(14),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javascript面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript面试题"}},[t._v("#")]),t._v(" JavaScript面试题")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("本篇主要介绍JS面试题。ES6相关的可能也会放在这里，手撕代码因为篇幅原因单独一篇")]),t._v(" "),a("hr")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#js有哪些数据类型-区别-存放位置"}},[t._v("JS有哪些数据类型？区别？存放位置？")])]),a("li",[a("a",{attrs:{href:"#判断数据类型的方法有哪些"}},[t._v("判断数据类型的方法有哪些？")])]),a("li",[a("a",{attrs:{href:"#null是对象吗-为什么"}},[t._v("null是对象吗？为什么？")])]),a("li",[a("a",{attrs:{href:"#_0-1-0-2-0-3-浮点数精度问题"}},[t._v("0.1+0.2!=0.3,浮点数精度问题")])]),a("li",[a("a",{attrs:{href:"#number强制转换对象类型返回值"}},[t._v("Number强制转换对象类型返回值？")])]),a("li",[a("a",{attrs:{href:"#_1-tostring-为什么可以调用"}},[t._v("‘1’.toString()为什么可以调用？")])]),a("li",[a("a",{attrs:{href:"#_1-2-3-map-parseint-的结果"}},[t._v("[1,2,3].map(parseInt)的结果？")])]),a("li",[a("a",{attrs:{href:"#和-的区别"}},[t._v("==和===的区别")])]),a("li",[a("a",{attrs:{href:"#object-is和-的区别"}},[t._v("Object.is和===的区别")])]),a("li",[a("a",{attrs:{href:"#js类型转换规则"}},[t._v("JS类型转换规则")])]),a("li",[a("a",{attrs:{href:"#对象类型转原始类型"}},[t._v("对象类型转原始类型")])]),a("li",[a("a",{attrs:{href:"#让if-a-1-a-2-a-3-成立"}},[t._v("让if( a==1 && a==2 && a==3 )成立")])]),a("li",[a("a",{attrs:{href:"#闭包是什么-作用-优缺点"}},[t._v("闭包是什么？作用？优缺点？")])]),a("li",[a("a",{attrs:{href:"#this的绑定规则"}},[t._v("this的绑定规则")])]),a("li",[a("a",{attrs:{href:"#new操作符干了什么"}},[t._v("new操作符干了什么？")])]),a("li",[a("a",{attrs:{href:"#作用域和作用域链"}},[t._v("作用域和作用域链")])]),a("li",[a("a",{attrs:{href:"#原型和原型链"}},[t._v("原型和原型链")])]),a("li",[a("a",{attrs:{href:"#function和object的关系"}},[t._v("Function和Object的关系")])]),a("li",[a("a",{attrs:{href:"#构造函数和原型对象的关系"}},[t._v("构造函数和原型对象的关系")])]),a("li",[a("a",{attrs:{href:"#js同名变量的优先级-函数名-函数参数名-内部变量"}},[t._v("JS同名变量的优先级(函数名，函数参数名，内部变量)")])]),a("li",[a("a",{attrs:{href:"#js实现继承的方法汇总-优缺点分析"}},[t._v("JS实现继承的方法汇总，优缺点分析")])]),a("li",[a("a",{attrs:{href:"#js数组-字符串等方法考察"}},[t._v("JS数组/字符串等方法考察")])]),a("li",[a("a",{attrs:{href:"#深拷贝-浅拷贝-是深拷贝吗"}},[t._v("深拷贝/浅拷贝？...是深拷贝吗？")])]),a("li",[a("a",{attrs:{href:"#模块化"}},[t._v("模块化")])]),a("li",[a("a",{attrs:{href:"#v8引擎如何进行垃圾回收"}},[t._v("V8引擎如何进行垃圾回收？")])]),a("li",[a("a",{attrs:{href:"#事件循环event-loop"}},[t._v("事件循环Event Loop")])]),a("li",[a("a",{attrs:{href:"#异步编程发展史"}},[t._v("异步编程发展史")])]),a("li",[a("a",{attrs:{href:"#await和promise的异常处理"}},[t._v("await和promise的异常处理，")])]),a("li",[a("a",{attrs:{href:"#异步编程方案-优缺点分析"}},[t._v("异步编程方案？优缺点分析")])]),a("li",[a("a",{attrs:{href:"#事件冒泡-捕获-委托"}},[t._v("事件冒泡/捕获/委托")])]),a("li",[a("a",{attrs:{href:"#跨域-原因和解决"}},[t._v("跨域，原因和解决")])]),a("li",[a("a",{attrs:{href:"#let和const"}},[t._v("let和const")])]),a("li",[a("a",{attrs:{href:"#symbol和bigint"}},[t._v("symbol和bigint")])]),a("li",[a("a",{attrs:{href:"#map和set区别-和object区别"}},[t._v("Map和Set区别？和Object区别？")])]),a("li",[a("a",{attrs:{href:"#weakmap和weakset"}},[t._v("WeakMap和WeakSet")])]),a("li",[a("a",{attrs:{href:"#箭头函数"}},[t._v("箭头函数")])]),a("li",[a("a",{attrs:{href:"#字符串-数组等拓展方法"}},[t._v("字符串/数组等拓展方法")])]),a("li",[a("a",{attrs:{href:"#promise串行和并行及异常处理"}},[t._v("Promise串行和并行及异常处理？")])]),a("li",[a("a",{attrs:{href:"#async-awiat"}},[t._v("async/awiat")])]),a("li",[a("a",{attrs:{href:"#proxy和reflect"}},[t._v("Proxy和Reflect")])]),a("li",[a("a",{attrs:{href:"#文件上传-拖拽-断点续传-妙传"}},[t._v("文件上传(拖拽/断点续传/妙传)")])]),a("li",[a("a",{attrs:{href:"#无缝轮播图"}},[t._v("无缝轮播图")])]),a("li",[a("a",{attrs:{href:"#虚拟滚动-延迟加载如何做-判断一个元素是否在可视区域中"}},[t._v("虚拟滚动，延迟加载如何做？判断一个元素是否在可视区域中")])]),a("li",[a("a",{attrs:{href:"#获取dom所有节点的数量"}},[t._v("获取DOM所有节点的数量")])]),a("li",[a("a",{attrs:{href:"#下拉刷新-加载"}},[t._v("下拉刷新/加载")])]),a("li",[a("a",{attrs:{href:"#单点登录"}},[t._v("单点登录")])]),a("li",[a("a",{attrs:{href:"#webpack优化"}},[t._v("webpack优化")])]),a("li",[a("a",{attrs:{href:"#面向过程、面向对象oop、函数式编程fp各自区别"}},[t._v("面向过程、面向对象OOP、函数式编程FP各自区别")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"js有哪些数据类型-区别-存放位置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js有哪些数据类型-区别-存放位置"}},[t._v("#")]),t._v(" JS有哪些数据类型？区别？存放位置？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("基本类型有七种： null、undefined、boolean、number、string、symbol、bigint")]),t._v(" "),a("li",[t._v("引用类型有一种: object(包含 array,function,date,regexp,map,set,weakmap,weakset)")]),t._v(" "),a("li",[t._v("基本类型值存放在"),a("strong",[t._v("栈")]),t._v("内存中，引用类型值存放在堆中，"),a("strong",[t._v("栈中存放指向堆内存的指针")]),t._v("。")])])]),a("h2",{attrs:{id:"判断数据类型的方法有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断数据类型的方法有哪些"}},[t._v("#")]),t._v(" 判断数据类型的方法有哪些？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("typeof (可以判断除了null的基本数据类型，引用类型都返回object)")]),t._v(" "),a("li",[t._v("instanceof (只能判断引用类型都)")]),t._v(" "),a("li",[t._v("Object.prototype.toString (可以判断所有类型)")]),t._v(" "),a("li",[t._v("根据对象的构造器constructor进行判断")]),t._v(" "),a("li",[t._v("Array.isArray (只能判断数组), NaN.isNaN(只能判断NaN)，Number.isInteger() (只能判断整数)")])])]),a("h2",{attrs:{id:"null是对象吗-为什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#null是对象吗-为什么"}},[t._v("#")]),t._v(" null是对象吗？为什么？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("null是一个基本类型，值为null，不是对象。")]),t._v(" "),a("li",[t._v("typeof null === 'object'，这是一个JS设计的BUG，因为改动会影响底层故保留这个BUG。")])])]),a("h2",{attrs:{id:"_0-1-0-2-0-3-浮点数精度问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2-0-3-浮点数精度问题"}},[t._v("#")]),t._v(" 0.1+0.2!=0.3,浮点数精度问题")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("浮点数 Value = sign  * exponent bias * fraction")]),t._v(" "),a("li",[t._v("JS采用IEEE 754编码，即用64位二进制数表示数字，"),a("strong",[t._v("符号位 sign")]),t._v("1位，"),a("strong",[t._v("指数偏移值exponent bias")]),t._v("11位，剩余的53位"),a("strong",[t._v("fraction")]),t._v("用来表示小数，而像0.1这种小数，转化成二进制是无限循环的，只能保留53位，所以在ES6前，JS最大的数字为2^53-1，即9007199254740991。")]),t._v(" "),a("li",[t._v("JS的number都是浮点型的，可以采用parseFloat((0.1+0.2).toFixed(10)) ===0.3来判断")])])]),a("h2",{attrs:{id:"number强制转换对象类型返回值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#number强制转换对象类型返回值"}},[t._v("#")]),t._v(" Number强制转换对象类型返回值？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")])]),a("h2",{attrs:{id:"_1-tostring-为什么可以调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-tostring-为什么可以调用"}},[t._v("#")]),t._v(" ‘1’.toString()为什么可以调用？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("原始类型是没有函数可以调用的，但是对象类型有toString方法，所以可以调用。")]),t._v(" "),a("li",[t._v("'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。")])])]),a("h2",{attrs:{id:"_1-2-3-map-parseint-的结果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-map-parseint-的结果"}},[t._v("#")]),t._v(" [1,2,3].map(parseInt)的结果？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("结果是："),a("code",[t._v("[1,NaN,NaN]")])])])]),a("h2",{attrs:{id:"和-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别"}},[t._v("#")]),t._v(" ==和===的区别")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("==判断值是否相等，类型不同会进行隐式类型转换")]),t._v(" "),a("li",[t._v("===判断值和类型是否相等，不会进行类型转换")]),t._v(" "),a("li",[t._v("避免错误尽量使用===")])])]),a("h2",{attrs:{id:"object-is和-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-is和-的区别"}},[t._v("#")]),t._v(" Object.is和===的区别")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("都用于判断两者是否相等，Object.is比三等能多判断 "),a("code",[t._v("NaN")]),t._v(","),a("code",[t._v("+0,-0")]),t._v("的相等")])])]),a("h2",{attrs:{id:"js类型转换规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js类型转换规则"}},[t._v("#")]),t._v(" JS类型转换规则")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("类型转换规则")]),a("ul",[a("li",[t._v("分两种情况 : 1.强制类型转换 2.隐式类型转换")]),t._v(" "),a("li",[t._v("其实就是Number、String、Boolean这三个类型之间的相互转化")]),t._v(" "),a("li",[t._v("内容有点多，后续补充。。")])])]),a("h2",{attrs:{id:"对象类型转原始类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象类型转原始类型"}},[t._v("#")]),t._v(" 对象类型转原始类型")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("对象转基本数据类型会进行以下操作\n"),a("ul",[a("li",[t._v("如果已经为原始数据，不需要转换")]),t._v(" "),a("li",[t._v("调用x.valueOf() 方法，如果转换为基本数据类型，则返回转换的值")]),t._v(" "),a("li",[t._v("调用x.toString()方法 方法，如果转换为基本数据类型，则返回转换的值")])])]),t._v(" "),a("li",[t._v("对象通过Number强行转换为NaN")])])]),a("h2",{attrs:{id:"让if-a-1-a-2-a-3-成立"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#让if-a-1-a-2-a-3-成立"}},[t._v("#")]),t._v(" 让if( a==1 && a==2 && a==3 )成立")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("重写valueOf()方法，读取的时候进行累加操作")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("valueOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])])]),a("h2",{attrs:{id:"闭包是什么-作用-优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包是什么-作用-优缺点"}},[t._v("#")]),t._v(" 闭包是什么？作用？优缺点？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("闭包: 有权访问另一个函数作用域中变量的函数")]),a("blockquote",[a("p",[t._v("函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。")])]),t._v(" "),a("ul",[a("li",[t._v("优点: 保护函数内的变量安全 ，实现封装，防止变量名污染作用域")]),t._v(" "),a("li",[t._v("缺点: 保持着对变量的引用，作用域链得不到释放，容易造成内存泄露")])])]),a("h2",{attrs:{id:"this的绑定规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this的绑定规则"}},[t._v("#")]),t._v(" this的绑定规则")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("this 优先级 new > 显式绑定 (call,apply,bind) > 隐式绑定 (obj.fn()) > 默认绑定 (fn())")]),a("ul",[a("li",[t._v("默认绑定")]),t._v(" "),a("li",[t._v("隐式绑定")]),t._v(" "),a("li",[t._v("显式绑定")]),t._v(" "),a("li",[t._v("new绑定")]),t._v(" "),a("li",[t._v("特殊情况: 1. 箭头函数 2. 严格模式")])])]),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("this绑定丢失")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br")]),a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 隐式绑定     obj调用，this指向obj")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// this绑定丢失 this指向window")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" method1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可以用bind()强绑定this，this指向不会再改变")]),t._v("\n")])]),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])])]),t._v(" "),a("h2",{attrs:{id:"new操作符干了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new操作符干了什么"}},[t._v("#")]),t._v(" new操作符干了什么？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("new做的四件事情")]),a("ol",[a("li",[t._v("创建一个空的简单JavaScript对象（即{}）；")]),t._v(" "),a("li",[t._v("为步骤1新创建的对象添加属性，将该属性链接至构造函数的原型对象 ；proto")]),t._v(" "),a("li",[t._v("将步骤1新创建的对象作为"),a("strong",[t._v("this")]),t._v("的上下文 ；")]),t._v(" "),a("li",[t._v("如果该函数没有返回对象，则返回"),a("strong",[t._v("this")]),t._v("。")])])]),a("h2",{attrs:{id:"作用域和作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域和作用域链"}},[t._v("#")]),t._v(" 作用域和作用域链")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("作用域和作用域链")]),a("ul",[a("li",[t._v("变量作用的范围叫作作用域")]),t._v(" "),a("li",[t._v("当前作用域不存在的变量和引用，就沿着作用域链继续寻找")])])]),a("h2",{attrs:{id:"原型和原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[t._v("#")]),t._v(" 原型和原型链")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("原型和原型链")]),a("ul",[a("li",[t._v("新建一个对象，会发现除了自己添加的还有很多属性，这些都是从原型上继承下来的")]),t._v(" "),a("li",[t._v("每个 JS 对象都有 "),a("strong",[t._v("proto")]),t._v(" 属性(浏览器实现，非标准)，这个属性指向了原型，实例对象."),a("strong",[t._v("proto")]),t._v(" === 原型对象.constructor")]),t._v(" "),a("li",[t._v("当在实例对象上找不到时，就会去原型上找，原型也有自己的原型，查找的过程就形成一条了原型链。")])])]),a("h2",{attrs:{id:"function和object的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function和object的关系"}},[t._v("#")]),t._v(" Function和Object的关系")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("Object 是所有对象的底层原型，所有对象都可以通过 "),a("strong",[t._v("proto")]),t._v(" 找到它")]),t._v(" "),a("li",[t._v("Function 是所有函数的顶层爸爸，所有函数都可以通过 "),a("strong",[t._v("proto")]),t._v(" 找到它")]),t._v(" "),a("li",[t._v("函数的 prototype 是一个对象")])])]),a("h2",{attrs:{id:"构造函数和原型对象的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造函数和原型对象的关系"}},[t._v("#")]),t._v(" 构造函数和原型对象的关系")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("在new关键词后面的函数就是 构造函数")]),t._v(" "),a("li",[t._v("原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型")])])]),a("h2",{attrs:{id:"js同名变量的优先级-函数名-函数参数名-内部变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js同名变量的优先级-函数名-函数参数名-内部变量"}},[t._v("#")]),t._v(" JS同名变量的优先级(函数名，函数参数名，内部变量)")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("函数形参可以看做是函数的局部变量，如果形参赋值，则()是一个单独的作用域，外层作用域是函数的作用域")]),t._v(" "),a("li",[t._v("函数名会覆盖形参名，变量名不会")])])]),a("h2",{attrs:{id:"js实现继承的方法汇总-优缺点分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js实现继承的方法汇总-优缺点分析"}},[t._v("#")]),t._v(" JS实现继承的方法汇总，优缺点分析")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ol",[a("li",[t._v("构造函数继承")]),t._v(" "),a("li",[t._v("原型继承")]),t._v(" "),a("li",[t._v("组合继承")]),t._v(" "),a("li",[t._v("寄生组合继承")]),t._v(" "),a("li",[t._v("圣杯继承")]),t._v(" "),a("li",[t._v("class继承(语法糖)")])])]),a("h2",{attrs:{id:"js数组-字符串等方法考察"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js数组-字符串等方法考察"}},[t._v("#")]),t._v(" JS数组/字符串等方法考察")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("会改变数组自身的七个方法: pop push shift unshift reverse sort splice")]),t._v(" "),a("li",[t._v("...后续更新")])])]),a("h2",{attrs:{id:"深拷贝-浅拷贝-是深拷贝吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝-浅拷贝-是深拷贝吗"}},[t._v("#")]),t._v(" 深拷贝/浅拷贝？...是深拷贝吗？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("深浅拷贝")]),a("ul",[a("li",[t._v("就是拷贝的层级，只能拷贝第一次则是浅拷贝，嵌套层级也能拷则是深拷贝(或者拷贝的数据是否和源对象共享)")]),t._v(" "),a("li",[t._v("除了深拷贝(1.JSON.parse(JSON.stringify() 2.手写深拷贝)) 都是浅拷贝")]),t._v(" "),a("li",[t._v("浅拷贝(1. ...拓展运算符 2.array.map 3. array.concat 4.Object.assign()等等都是)")])])]),a("h2",{attrs:{id:"模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[t._v("#")]),t._v(" 模块化")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("模块化")]),a("ul",[a("li",[t._v("防止命名冲突")]),t._v(" "),a("li",[t._v("可复用代码")]),t._v(" "),a("li",[t._v("拆分成不同模块方便维护")])]),t._v(" "),a("blockquote",[a("p",[t._v("模块化方案:")])]),t._v(" "),a("ul",[a("li",[t._v("AMD 和 CMD(历史方案)")]),t._v(" "),a("li",[t._v("CommonJS(node.js专用，不属于JS规范)")]),t._v(" "),a("li",[t._v("Esmodule(js原生实现的模块化方案)")])])]),a("h2",{attrs:{id:"v8引擎如何进行垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎如何进行垃圾回收"}},[t._v("#")]),t._v(" V8引擎如何进行垃圾回收？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("p",[t._v("这个有点复杂,至今还未完全理解")]),t._v(" "),a("ul",[a("li",[t._v("标记清除算法")]),t._v(" "),a("li",[t._v("标记压缩算法")])])]),a("h2",{attrs:{id:"事件循环event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环event-loop"}},[t._v("#")]),t._v(" 事件循环Event Loop")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ol",[a("li",[t._v("执⾏同步代码，这属于宏任务")]),t._v(" "),a("li",[t._v("执⾏栈为空，查询是否有微任务需要执⾏")]),t._v(" "),a("li",[t._v("执⾏所有微任务")]),t._v(" "),a("li",[t._v("必要的话渲染 UI")]),t._v(" "),a("li",[t._v("然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码")])])]),a("h2",{attrs:{id:"异步编程发展史"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步编程发展史"}},[t._v("#")]),t._v(" 异步编程发展史")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("回调函数(callback) -> 期约(Promise) -> 生成器generator -> async/await")]),a("ul",[a("li",[t._v("这里内容有点多，先列个大纲")]),t._v(" "),a("li",[t._v("回调地狱")]),t._v(" "),a("li",[t._v("Promise不够优雅")]),t._v(" "),a("li",[t._v("await到底在等什么")])])]),a("h2",{attrs:{id:"await和promise的异常处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#await和promise的异常处理"}},[t._v("#")]),t._v(" await和promise的异常处理，")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("rs")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Error'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'异常被捕获到了1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("rs")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Error'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'异常被捕获到了2'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br")])]),a("blockquote",[a("p",[t._v("第一个 Promise 里的异常能被捕获，因为 Promise 里同步抛出的异常，也会被视为Promise.reject。但第二个 Promise，由于里面的函数是 async 的，异常是异步抛出的，所以并不会触发 Promise 的 reject ，因此 Promise.catch 也就捕获不到")])]),t._v(" "),a("h2",{attrs:{id:"异步编程方案-优缺点分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步编程方案-优缺点分析"}},[t._v("#")]),t._v(" 异步编程方案？优缺点分析")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ol",[a("li",[t._v("回调函数")]),t._v(" "),a("li",[t._v("Promise")]),t._v(" "),a("li",[t._v("Generator")]),t._v(" "),a("li",[t._v("async/await")])])]),a("h2",{attrs:{id:"事件冒泡-捕获-委托"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡-捕获-委托"}},[t._v("#")]),t._v(" 事件冒泡/捕获/委托")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("这些是浏览器的事件机制")]),a("ol",[a("li",[t._v("事件冒泡是从里到外依次触发")]),t._v(" "),a("li",[t._v("事件捕获是从外到里依次触发")]),t._v(" "),a("li",[t._v("事件委托利用的事件冒泡机制")])])]),a("h2",{attrs:{id:"跨域-原因和解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨域-原因和解决"}},[t._v("#")]),t._v(" 跨域，原因和解决")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("跨域是由于浏览器的同源策略")]),a("blockquote",[a("p",[t._v("同源策略")])]),t._v(" "),a("ul",[a("li",[t._v("域名、协议、端口号要一致，否则ajax请求失败")])]),t._v(" "),a("blockquote",[a("p",[t._v("为什么要有同源策略？")])]),t._v(" "),a("ul",[a("li",[t._v("只有"),a("strong",[t._v("浏览器")]),t._v("才会存在跨域,服务器或者小程序这些是不存在跨域的。")]),t._v(" "),a("li",[t._v("是出于安全考虑，没有同源策略限制，你网站的cookie就会被任意来源的ajax获取，泄露信息。")])]),t._v(" "),a("blockquote",[a("p",[t._v("跨域解决方案")])]),t._v(" "),a("ul",[a("li",[t._v("jsonp")]),t._v(" "),a("li",[t._v("cors")]),t._v(" "),a("li",[t._v("node.js正向代理")]),t._v(" "),a("li",[t._v("nginx反向代理")]),t._v(" "),a("li",[t._v("webpack/vite/axios 配置 proxy")]),t._v(" "),a("li",[t._v("websocket(本身不存在跨域限制)")]),t._v(" "),a("li",[t._v("iframe + windows.postmessage")]),t._v(" "),a("li",[t._v("iframe + windows.document.domain")]),t._v(" "),a("li",[t._v("iframe + location.hash")]),t._v(" "),a("li",[t._v("浏览器开启跨域，不推荐")])])]),a("h1",{attrs:{id:"es6考察"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6考察"}},[t._v("#")]),t._v(" es6考察")]),t._v(" "),a("h2",{attrs:{id:"let和const"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let和const"}},[t._v("#")]),t._v(" let和const")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("let 和 const 拥有块级作用域， 只要{} 里面有let 就是块级作用域")]),t._v(" "),a("li",[t._v("存在TDZ(Temporal Dead Zone),不能在声明前访问")]),t._v(" "),a("li",[t._v("因为TDZ的原因，表现得没有‘提升’,实际上在JavaScript中，任何声明都有提升")]),t._v(" "),a("li",[t._v("不能重复声明,let声明变量，const声明常量，const定义对象，对象值可以修改")]),t._v(" "),a("li")])]),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[t._v("JavaScript所有声明都有提升")]),t._v(" "),a("p",[t._v("包括 var、let、const、class、function，其中函数声明提升 优先于 变量声明提升")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'parent value'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Uncaught ReferenceError: x is not defined")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'child value'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n如果"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v("不存在变量提升的话， console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("中的x会顺着作用域链找到上一层作用域的"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" x，打印出\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'parnent value'")]),t._v("，但实际上是报了ReferenceError的错，也就证明"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v("是存在变量提升的\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("h2",{attrs:{id:"symbol和bigint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#symbol和bigint"}},[t._v("#")]),t._v(" symbol和bigint")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("symbol是ES6加入的，bigint是ES10加入的")]),a("blockquote",[a("p",[t._v("Symbol")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("防止变量名起冲突")])]),t._v(" "),a("li",[a("strong",[t._v("symbol作为键名时，不会被常规方法遍历出来，所以可以作对象私有属性和方法")])])]),t._v(" "),a("blockquote",[a("p",[t._v("biging")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("解决JavaScript最大只能表示 2^53 - 1 个数字的问题")])])])]),a("h2",{attrs:{id:"map和set区别-和object区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map和set区别-和object区别"}},[t._v("#")]),t._v(" Map和Set区别？和Object区别？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("Map叫字典/哈希表，Set叫集合")]),a("blockquote",[a("p",[t._v("Map和Set区别")])]),t._v(" "),a("ul",[a("li",[t._v("Map和Set都可以储存不重复的key，不过Map是[key,value]，Set是[value] 或者[value,value]")])]),t._v(" "),a("blockquote",[a("p",[t._v("Map和Object的区别")])]),t._v(" "),a("ul",[a("li",[t._v("Object的key只能是string类型或者symbol，而set和map可以是任意类型")]),t._v(" "),a("li",[t._v("Map是可以被迭代(iterable)的，Object不可以。")])])]),a("h2",{attrs:{id:"weakmap和weakset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#weakmap和weakset"}},[t._v("#")]),t._v(" WeakMap和WeakSet")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("其中的键是弱引用的,其键key必须是对象，而值value可以是任意的。")]),t._v(" "),a("li",[t._v("原生的 WeakMap 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。")]),t._v(" "),a("li",[t._v("正由于这样的弱引用，WeakMap 的 key 是不可枚举的")])])]),a("h2",{attrs:{id:"箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" 箭头函数")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("没有argument，没有构造函数，不能new")]),t._v(" "),a("li",[t._v("没有自己的this，this继承外层普通函数function，this指向不会改变")])])]),a("h2",{attrs:{id:"字符串-数组等拓展方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串-数组等拓展方法"}},[t._v("#")]),t._v(" 字符串/数组等拓展方法")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("这个太多了")])])]),a("h2",{attrs:{id:"promise串行和并行及异常处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise串行和并行及异常处理"}},[t._v("#")]),t._v(" Promise串行和并行及异常处理？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("blockquote",[a("p",[t._v("串行:  promise.then() 链式操作\n并行: promise.all()")])])]),a("h2",{attrs:{id:"async-awiat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-awiat"}},[t._v("#")]),t._v(" async/awiat")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("blockquote",[a("p",[t._v("async")])]),t._v(" "),a("ul",[a("li",[t._v("⼀个函数如果加上 async ，那么该函数就会返回⼀个 Promise")])]),t._v(" "),a("blockquote",[a("p",[t._v("await")])]),t._v(" "),a("ul",[a("li",[t._v("await 只能在 async 函数中使⽤")]),t._v(" "),a("li",[t._v("await下面的代码可以看做是promise.then()")])])]),a("h2",{attrs:{id:"proxy和reflect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy和reflect"}},[t._v("#")]),t._v(" Proxy和Reflect")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")])]),a("h1",{attrs:{id:"场景题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景题"}},[t._v("#")]),t._v(" 场景题")]),t._v(" "),a("h2",{attrs:{id:"文件上传-拖拽-断点续传-妙传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件上传-拖拽-断点续传-妙传"}},[t._v("#")]),t._v(" 文件上传(拖拽/断点续传/妙传)")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("获取文件对象 转换成二进制(blob/stream/buffer)")]),t._v(" "),a("li",[t._v("拖拽API")]),t._v(" "),a("li",[t._v("状态码206分片上传断点续传")])])]),a("h2",{attrs:{id:"无缝轮播图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无缝轮播图"}},[t._v("#")]),t._v(" 无缝轮播图")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ul",[a("li",[t._v("设置2个index，12345 -> 23451-> 34512 -> 45123 -> 51234 -> 12345")]),t._v(" "),a("li",[t._v("多复制一份原有容器的图片数量，到最后一张偏移位置置位0")]),t._v(" "),a("li",[t._v("用swiper插件🤣")])])]),a("h2",{attrs:{id:"虚拟滚动-延迟加载如何做-判断一个元素是否在可视区域中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟滚动-延迟加载如何做-判断一个元素是否在可视区域中"}},[t._v("#")]),t._v(" 虚拟滚动，延迟加载如何做？判断一个元素是否在可视区域中")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("blockquote",[a("p",[t._v("懒加载就是将不关键的资源延后加载。")])]),t._v(" "),a("p",[t._v("原理就是只加载页面的可视区域，不断动态替换页面可视区域的DOM节点。")]),t._v(" "),a("ul",[a("li",[t._v("对于图片来说，src属性可以先给个小体积的，真正的图片地址用自定义属性data-url存储，当图片出现在可视区域的时候才去下载真正地图片，实现了图片懒加载。")]),t._v(" "),a("li",[t._v("懒加载除了用在图片，也可以使用在其他资源。比如进入可视区域才开始播放视频等等。")])])]),a("h2",{attrs:{id:"获取dom所有节点的数量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取dom所有节点的数量"}},[t._v("#")]),t._v(" 获取DOM所有节点的数量")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("p",[a("code",[t._v("document.querySelectorAll('*').length")])])]),a("h2",{attrs:{id:"下拉刷新-加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下拉刷新-加载"}},[t._v("#")]),t._v(" 下拉刷新/加载")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")])]),a("h2",{attrs:{id:"单点登录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单点登录"}},[t._v("#")]),t._v(" 单点登录")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("blockquote",[a("p",[t._v("得分情况，在同域名下的单点登录，和不同域名下的单点登录")])]),t._v(" "),a("ul",[a("li",[t._v("认证中心")])])]),a("h2",{attrs:{id:"webpack优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack优化"}},[t._v("#")]),t._v(" webpack优化")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("webpack")]),a("ul",[a("li",[t._v("优化 Loader 的文件搜索范围")]),t._v(" "),a("li",[t._v("Loader已经编译过的代码不改变直接缓存起来")]),t._v(" "),a("li",[t._v("代码压缩")]),t._v(" "),a("li",[t._v("按需加载")]),t._v(" "),a("li",[t._v("Tree Shaking(需要ESmodule支持)")])])]),a("h2",{attrs:{id:"面向过程、面向对象oop、函数式编程fp各自区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向过程、面向对象oop、函数式编程fp各自区别"}},[t._v("#")]),t._v(" 面向过程、面向对象OOP、函数式编程FP各自区别")]),t._v(" "),a("blockquote",[a("p",[t._v("面向过程 (Procedure-Oriented Programming)\n代表语言: C / Golang\n面向对象 (Object Oriented Programming)\n代表语言: C++ / C# / Java / Python / Golang\n函数式编程 (Function Programming)\n代表语言: Lisp,JS,Rust")])]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("编程方式区别")]),a("ul",[a("li",[t._v("程序本质就是操作数据，oop和fp都把数据封装到属性中，")]),t._v(" "),a("li",[t._v("oop通过对象封装和操作属性。fp通过函数来操作属性")]),t._v(" "),a("li",[t._v("函数式编程对开发者要求更高一些，需要对程序的理解更深入。面向对象则更浅显，所以为了让公司里面良莠不齐的开发人员统一协作，就逐渐采用了以面向对象为主的开发模式。")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);