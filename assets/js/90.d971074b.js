(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{609:function(t,e,r){"use strict";r.r(e);var n=r(13),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"创建空对象的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建空对象的区别"}},[t._v("#")]),t._v(" 创建空对象的区别")]),t._v(" "),r("p",[t._v("Object.create() 创建一个对象并把这个对象的[[prototype]] 关联到指定的对象")]),t._v(" "),r("p",[t._v("如Object.create() 创建一个空对象，原型为null，而{} 也是空对象，但原型为Object")]),t._v(" "),r("p",[t._v("因此Object.create() 比 {} 更”空”！")]),t._v(" "),r("h2",{attrs:{id:"for-in-和-in"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#for-in-和-in"}},[t._v("#")]),t._v(" for ... in 和 in")]),t._v(" "),r("p",[t._v("使用for..in 的原理和在原型链上查找类似，任何可以通过原型链访问到的属性(enumerable要为true)都会被枚举。")]),t._v(" "),r("blockquote",[r("p",[t._v("Symbol是不可枚举的，所以可以用来作对象私有属性")])]),t._v(" "),r("p",[t._v("in 操作符也是类似的， 但是不论属性 是否是 可枚举的")])])}),[],!1,null,null,null);e.default=a.exports}}]);