(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{678:function(t,e,v){"use strict";v.r(e);var i=v(13),a=Object(i.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"vite"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[t._v("#")]),t._v(" Vite")]),t._v(" "),v("p",[v("strong",[t._v("开发下使用esbuild(Go编写的构建工具)，生产环境下使用rollup(Svelte作者用JS写的一个打包工具)")])]),t._v(" "),v("h2",{attrs:{id:"为什么选择vite"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么选择vite"}},[t._v("#")]),t._v(" 为什么选择Vite？")]),t._v(" "),v("p",[t._v("因为使用Vite构建项目比webpack快得多！！！打包快如闪电！")]),t._v(" "),v("h2",{attrs:{id:"vite快的原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vite快的原因"}},[t._v("#")]),t._v(" Vite快的原因")]),t._v(" "),v("p",[t._v("浏览器之前是不支持ES Modules的，就是通过import，export来导入导出模块，所以需要借助类似webpack的打包工具，")]),t._v(" "),v("ul",[v("li",[t._v("vite 主要对应的场景是开发模式，它只启动一台静态页面的服务器，对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理")]),t._v(" "),v("li",[t._v("底层实现上，Vite 是基于 esbuild 预构建依赖的。当声明一个script标签类型为module时，浏览器将对其内部的import引用发起HTTP请求获取模块内容；")]),t._v(" "),v("li",[t._v("Vite 劫持了这些请求，并在后端进行相应的处理（如处理.ts文件为.js文件），然后再返回给浏览器；")]),t._v(" "),v("li",[t._v("由于浏览器只会对用到的模块发起 HTTP 请求，所以 Vite 没必要对项目里所有的文件先打包后返回，而是只编译浏览器发起 HTTP 请求的模块即可。也就实现了所谓的按需加载。")])]),t._v(" "),v("h2",{attrs:{id:"冷启动和热更新时候webpack和vite的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#冷启动和热更新时候webpack和vite的区别"}},[t._v("#")]),t._v(" 冷启动和热更新时候webpack和vite的区别")]),t._v(" "),v("blockquote",[v("p",[t._v("冷启动webpack做了什么\n总的来说，webpack的热更新就是，当我们对代码做修改并保存后，webpack会对修改的代码块进行重新打包，并将新的模块发送至浏览器端，浏览器用新的模块代替旧的模块，从而实现了在不刷新浏览器的前提下更新页面。相比起直接刷新页面的方案，HMR的优点是可以保存应用的状态。当然，随着项目体积的增长，热更新的速度也会随之下降。")])]),t._v(" "),v("blockquote",[v("p",[t._v("冷启动vite做了什么")])]),t._v(" "),v("blockquote",[v("p",[t._v("热更新webpack做了什么")])]),t._v(" "),v("blockquote",[v("p",[t._v("热更新vite做了什么")])]),t._v(" "),v("p",[t._v("热更新主要与项目编写的源码有关。前面提到，对于源码，vite使用原生esm方式去处理，在浏览器请求源码文件时，对文件进行处理后返回转换后的源码。vite对于热更新的实现，大致可以分为三步：")]),t._v(" "),v("ol",[v("li",[t._v("监听文件变动")]),t._v(" "),v("li",[t._v("读取文件内容")]),t._v(" "),v("li",[t._v("通知浏览器做相应的更新")])]),t._v(" "),v("h2",{attrs:{id:"热更新的实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#热更新的实现原理"}},[t._v("#")]),t._v(" 热更新的实现原理")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("创建一个websocket服务端。vite执行createWebSocketServer函数，调用ws库创建ws服务端。")])]),t._v(" "),v("li",[v("p",[t._v("创建一个ws客户端来接收ws服务端的信息。vite首先会创建一个ws client文件，然后在处理入口文件index.html时，把对ws client文件的引入注入到index.html文件中。当浏览器访问index.html时，就会加载ws client文件并执行，创建一个客户端ws，从而接收ws服务端的信息。")])]),t._v(" "),v("li",[v("p",[t._v("服务端监听文件变化，发送websocket消息，通知客户端。")])]),t._v(" "),v("li",[v("p",[t._v("服务端调用handleHMRUpdate函数，该函数会根据此次修改文件的类型，通知客户端是要刷新还是重新加载文件。")])]),t._v(" "),v("li",[v("p",[t._v("一个小细节：vite对于node_modules的文件做了强缓存，而对我们编写的源码做了协商缓存")])])]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("ul",[v("li",[t._v("构建速度快：Webpack 会先将代码打包，然后启动开发服务器，请求服务器时返回打包后的结果；而 Vite 是直接启动开发服务器，请求哪个模块再对该模块进行实时编译，省去了打包的过程。")]),t._v(" "),v("li",[t._v("热更新快：相比起webpack，vite会让浏览器帮忙做更多的事情。vite 采用立即编译当前修改文件的办法，当改动了一个模块后，仅需让浏览器重新请求该模块即可。同时 vite 还会使用缓存机制( http 缓存、 vite 内置缓存 )，加载更新后的文件内容。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);