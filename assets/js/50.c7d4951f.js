(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{633:function(t,a,s){"use strict";s.r(a);var i=s(14),e=Object(i.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"javascript面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript面试题"}},[t._v("#")]),t._v(" JavaScript面试题")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("本篇主要介绍JS面试题。ES6相关的可能也会放在这里，手撕代码因为篇幅原因单独一篇")]),t._v(" "),s("hr")]),t._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#js有哪些数据类型-区别-存放位置"}},[t._v("JS有哪些数据类型？区别？存放位置？")])]),s("li",[s("a",{attrs:{href:"#判断数据类型的方法有哪些"}},[t._v("判断数据类型的方法有哪些？")])]),s("li",[s("a",{attrs:{href:"#null是对象吗-为什么"}},[t._v("null是对象吗？为什么？")])]),s("li",[s("a",{attrs:{href:"#_0-1-0-2-0-3-浮点数精度问题"}},[t._v("0.1+0.2!=0.3,浮点数精度问题")])]),s("li",[s("a",{attrs:{href:"#number强制转换对象类型返回值"}},[t._v("Number强制转换对象类型返回值？")])]),s("li",[s("a",{attrs:{href:"#_1-tostring-为什么可以调用"}},[t._v("‘1’.toString()为什么可以调用？")])]),s("li",[s("a",{attrs:{href:"#_1-2-3-map-parseint-的结果"}},[t._v("[1,2,3].map(parseInt)的结果？")])]),s("li",[s("a",{attrs:{href:"#和-的区别"}},[t._v("==和===的区别")])]),s("li",[s("a",{attrs:{href:"#object-is和-的区别"}},[t._v("Object.is和===的区别")])]),s("li",[s("a",{attrs:{href:"#js类型转换规则"}},[t._v("JS类型转换规则")])]),s("li",[s("a",{attrs:{href:"#对象类型转原始类型"}},[t._v("对象类型转原始类型")])]),s("li",[s("a",{attrs:{href:"#让if-a-1-a-2-a-3-成立"}},[t._v("让if(a==1&&a==2&&a==3)成立")])]),s("li",[s("a",{attrs:{href:"#闭包是什么-作用-优缺点"}},[t._v("闭包是什么？作用？优缺点？")])]),s("li",[s("a",{attrs:{href:"#this的绑定规则"}},[t._v("this的绑定规则")])]),s("li",[s("a",{attrs:{href:"#new操作符干了什么"}},[t._v("new操作符干了什么？")])]),s("li",[s("a",{attrs:{href:"#作用域和作用域链"}},[t._v("作用域和作用域链")])]),s("li",[s("a",{attrs:{href:"#原型和原型链"}},[t._v("原型和原型链")])]),s("li",[s("a",{attrs:{href:"#function和object的关系"}},[t._v("Function和Object的关系")])]),s("li",[s("a",{attrs:{href:"#构造函数和原型对象的关系"}},[t._v("构造函数和原型对象的关系")])]),s("li",[s("a",{attrs:{href:"#js同名变量的优先级-函数名-函数参数名-内部变量"}},[t._v("JS同名变量的优先级(函数名，函数参数名，内部变量)")])]),s("li",[s("a",{attrs:{href:"#js实现继承的方法汇总-优缺点分析"}},[t._v("JS实现继承的方法汇总，优缺点分析")])]),s("li",[s("a",{attrs:{href:"#js数组-字符串等方法考察"}},[t._v("JS数组/字符串等方法考察")])]),s("li",[s("a",{attrs:{href:"#深拷贝-浅拷贝-是深拷贝吗"}},[t._v("深拷贝/浅拷贝？...是深拷贝吗？")])]),s("li",[s("a",{attrs:{href:"#v8引擎如何进行垃圾回收"}},[t._v("V8引擎如何进行垃圾回收？")])]),s("li",[s("a",{attrs:{href:"#事件循环event-loop"}},[t._v("事件循环Event Loop")])]),s("li",[s("a",{attrs:{href:"#异步编程方案-优缺点分析"}},[t._v("异步编程方案？优缺点分析")])]),s("li",[s("a",{attrs:{href:"#事件冒泡-捕获-委托"}},[t._v("事件冒泡/捕获/委托")])]),s("li",[s("a",{attrs:{href:"#跨域-原因和解决"}},[t._v("跨域，原因和解决")])]),s("li",[s("a",{attrs:{href:"#let和const-提升-块级作用域-tdz"}},[t._v("let和const(提升/块级作用域/TDZ)")])]),s("li",[s("a",{attrs:{href:"#symbol和bigint"}},[t._v("symbol和bigint")])]),s("li",[s("a",{attrs:{href:"#map和set区别-和object区别"}},[t._v("Map和Set区别？和Object区别？")])]),s("li",[s("a",{attrs:{href:"#weakmap和weakset"}},[t._v("WeakMap和WeakSet")])]),s("li",[s("a",{attrs:{href:"#箭头函数"}},[t._v("箭头函数")])]),s("li",[s("a",{attrs:{href:"#字符串-数组等拓展方法"}},[t._v("字符串/数组等拓展方法")])]),s("li",[s("a",{attrs:{href:"#promise串行和并行及异常处理"}},[t._v("Promise串行和并行及异常处理？")])]),s("li",[s("a",{attrs:{href:"#async-awiat"}},[t._v("async/awiat")])]),s("li",[s("a",{attrs:{href:"#proxy和reflect"}},[t._v("Proxy和Reflect")])]),s("li",[s("a",{attrs:{href:"#文件上传-拖拽-断点续传-妙传"}},[t._v("文件上传(拖拽/断点续传/妙传)")])]),s("li",[s("a",{attrs:{href:"#无缝轮播图"}},[t._v("无缝轮播图")])]),s("li",[s("a",{attrs:{href:"#虚拟滚动-延迟加载如何做-判断一个元素是否在可视区域中"}},[t._v("虚拟滚动，延迟加载如何做？判断一个元素是否在可视区域中")])]),s("li",[s("a",{attrs:{href:"#获取dom所有节点的数量"}},[t._v("获取DOM所有节点的数量")])]),s("li",[s("a",{attrs:{href:"#下拉刷新-加载"}},[t._v("下拉刷新/加载")])]),s("li",[s("a",{attrs:{href:"#单点登录"}},[t._v("单点登录")])])])]),s("p"),t._v(" "),s("h2",{attrs:{id:"js有哪些数据类型-区别-存放位置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js有哪些数据类型-区别-存放位置"}},[t._v("#")]),t._v(" JS有哪些数据类型？区别？存放位置？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"判断数据类型的方法有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#判断数据类型的方法有哪些"}},[t._v("#")]),t._v(" 判断数据类型的方法有哪些？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"null是对象吗-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#null是对象吗-为什么"}},[t._v("#")]),t._v(" null是对象吗？为什么？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"_0-1-0-2-0-3-浮点数精度问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2-0-3-浮点数精度问题"}},[t._v("#")]),t._v(" 0.1+0.2!=0.3,浮点数精度问题")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"number强制转换对象类型返回值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#number强制转换对象类型返回值"}},[t._v("#")]),t._v(" Number强制转换对象类型返回值？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"_1-tostring-为什么可以调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-tostring-为什么可以调用"}},[t._v("#")]),t._v(" ‘1’.toString()为什么可以调用？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"_1-2-3-map-parseint-的结果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-map-parseint-的结果"}},[t._v("#")]),t._v(" [1,2,3].map(parseInt)的结果？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("p",[t._v("1,NaN,NaN")])]),s("h2",{attrs:{id:"和-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别"}},[t._v("#")]),t._v(" ==和===的区别")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("==判断值是否相等，类型不同会进行隐式类型转换")]),t._v(" "),s("li",[t._v("===判断值和类型是否相等，不会进行类型转换")]),t._v(" "),s("li",[t._v("避免错误尽量使用===")])])]),s("h2",{attrs:{id:"object-is和-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-is和-的区别"}},[t._v("#")]),t._v(" Object.is和===的区别")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("都用于判断两者是否相等，Object.is比三等能多判断 "),s("code",[t._v("NaN")]),t._v(","),s("code",[t._v("+0,-0")]),t._v("的相等")])])]),s("h2",{attrs:{id:"js类型转换规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js类型转换规则"}},[t._v("#")]),t._v(" JS类型转换规则")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("分两种情况 : 1.强制类型转换 2.隐式类型转换")]),t._v(" "),s("li",[t._v("其实就是Number、String、Boolean这三个类型直接的相互转化")])])]),s("h2",{attrs:{id:"对象类型转原始类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象类型转原始类型"}},[t._v("#")]),t._v(" 对象类型转原始类型")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("toString()方法")])])]),s("h2",{attrs:{id:"让if-a-1-a-2-a-3-成立"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#让if-a-1-a-2-a-3-成立"}},[t._v("#")]),t._v(" 让if(a==1&&a==2&&a==3)成立")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("valueOf()方法")])])]),s("h2",{attrs:{id:"闭包是什么-作用-优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包是什么-作用-优缺点"}},[t._v("#")]),t._v(" 闭包是什么？作用？优缺点？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"this的绑定规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this的绑定规则"}},[t._v("#")]),t._v(" this的绑定规则")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("blockquote",[s("p",[t._v("优先级 new > 显式绑定 (call,apply,bind) > 隐式绑定 (obj.fn()) > 默认绑定 (fn())")])]),t._v(" "),s("ul",[s("li",[t._v("默认绑定")]),t._v(" "),s("li",[t._v("隐式绑定")]),t._v(" "),s("li",[t._v("显式绑定")]),t._v(" "),s("li",[t._v("new绑定")]),t._v(" "),s("li",[t._v("特殊情况: 1. 箭头函数 2. 严格模式")])])]),s("h2",{attrs:{id:"new操作符干了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new操作符干了什么"}},[t._v("#")]),t._v(" new操作符干了什么？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ol",[s("li",[t._v("创建一个空的简单JavaScript对象（即{}）；")]),t._v(" "),s("li",[t._v("为步骤1新创建的对象添加属性，将该属性链接至构造函数的原型对象 ；proto")]),t._v(" "),s("li",[t._v("将步骤1新创建的对象作为"),s("strong",[t._v("this")]),t._v("的上下文 ；")]),t._v(" "),s("li",[t._v("如果该函数没有返回对象，则返回"),s("strong",[t._v("this")]),t._v("。")])])]),s("h2",{attrs:{id:"作用域和作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域和作用域链"}},[t._v("#")]),t._v(" 作用域和作用域链")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"原型和原型链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[t._v("#")]),t._v(" 原型和原型链")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"function和object的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function和object的关系"}},[t._v("#")]),t._v(" Function和Object的关系")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"构造函数和原型对象的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数和原型对象的关系"}},[t._v("#")]),t._v(" 构造函数和原型对象的关系")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"js同名变量的优先级-函数名-函数参数名-内部变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js同名变量的优先级-函数名-函数参数名-内部变量"}},[t._v("#")]),t._v(" JS同名变量的优先级(函数名，函数参数名，内部变量)")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("函数形参可以看做是函数的局部变量，如果形参赋值，则()是一个单独的作用域，外层作用域是函数的作用域")]),t._v(" "),s("li",[t._v("函数名会覆盖形参名，变量名不会")])])]),s("h2",{attrs:{id:"js实现继承的方法汇总-优缺点分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js实现继承的方法汇总-优缺点分析"}},[t._v("#")]),t._v(" JS实现继承的方法汇总，优缺点分析")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ol",[s("li",[t._v("构造函数继承")]),t._v(" "),s("li",[t._v("原型继承")]),t._v(" "),s("li",[t._v("组合继承")]),t._v(" "),s("li",[t._v("寄生组合继承")]),t._v(" "),s("li",[t._v("圣杯继承")]),t._v(" "),s("li",[t._v("class继承(语法糖)")])])]),s("h2",{attrs:{id:"js数组-字符串等方法考察"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js数组-字符串等方法考察"}},[t._v("#")]),t._v(" JS数组/字符串等方法考察")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"深拷贝-浅拷贝-是深拷贝吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝-浅拷贝-是深拷贝吗"}},[t._v("#")]),t._v(" 深拷贝/浅拷贝？...是深拷贝吗？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("就是拷贝的层级，只能拷贝第一次则是浅拷贝，嵌套层级也能拷则是深拷贝")]),t._v(" "),s("li",[t._v("除了深拷贝(1.JSON.parse(JSON.stringify() 2.手写深拷贝)) 都是浅拷贝")]),t._v(" "),s("li",[t._v("浅拷贝(1. ...拓展运算符 2.array.map 3. array.concat 等等都是)")])])]),s("h2",{attrs:{id:"v8引擎如何进行垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎如何进行垃圾回收"}},[t._v("#")]),t._v(" V8引擎如何进行垃圾回收？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("p",[t._v("这个有点复杂")])]),s("h2",{attrs:{id:"事件循环event-loop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件循环event-loop"}},[t._v("#")]),t._v(" 事件循环Event Loop")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"异步编程方案-优缺点分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步编程方案-优缺点分析"}},[t._v("#")]),t._v(" 异步编程方案？优缺点分析")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ol",[s("li",[t._v("回调函数")]),t._v(" "),s("li",[t._v("Promise")]),t._v(" "),s("li",[t._v("Generator")]),t._v(" "),s("li",[t._v("async/await")])])]),s("h2",{attrs:{id:"事件冒泡-捕获-委托"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡-捕获-委托"}},[t._v("#")]),t._v(" 事件冒泡/捕获/委托")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("blockquote",[s("p",[t._v("这些是浏览器的事件机制")])]),t._v(" "),s("ol",[s("li",[t._v("事件冒泡是从里到外依次触发")]),t._v(" "),s("li",[t._v("事件捕获是从外到里依次触发")]),t._v(" "),s("li",[t._v("事件委托利用的事件冒泡机制")])])]),s("h2",{attrs:{id:"跨域-原因和解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨域-原因和解决"}},[t._v("#")]),t._v(" 跨域，原因和解决")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("跨域是由于浏览器的同源策略")]),t._v(" "),s("blockquote",[s("p",[t._v("同源策略")])]),t._v(" "),s("ul",[s("li",[t._v("域名、协议、端口号要一致，否则ajax请求失败")])]),t._v(" "),s("blockquote",[s("p",[t._v("为什么要有同源策略？")])]),t._v(" "),s("ul",[s("li",[t._v("只有"),s("strong",[t._v("浏览器")]),t._v("才会存在跨域,服务器或者小程序这些是不存在跨域的。")]),t._v(" "),s("li",[t._v("是出于安全考虑，没有同源策略限制，你网站的cookie就会被任意来源的ajax获取，泄露信息。")])]),t._v(" "),s("blockquote",[s("p",[t._v("跨域解决方案")])]),t._v(" "),s("ul",[s("li",[t._v("jsonp")]),t._v(" "),s("li",[t._v("cors")]),t._v(" "),s("li",[t._v("node.js正向代理")]),t._v(" "),s("li",[t._v("nginx反向代理")]),t._v(" "),s("li",[t._v("webpack/vite/axios 配置 proxy")]),t._v(" "),s("li",[t._v("websocket(本身不存在跨域限制)")]),t._v(" "),s("li",[t._v("iframe + windows.postmessage")]),t._v(" "),s("li",[t._v("iframe + windows.document.domain\n")]),t._v(" "),s("li",[t._v("浏览器开启跨域，不推荐")])])])]),s("h1",{attrs:{id:"es6考察"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6考察"}},[t._v("#")]),t._v(" es6考察")]),t._v(" "),s("h2",{attrs:{id:"let和const-提升-块级作用域-tdz"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#let和const-提升-块级作用域-tdz"}},[t._v("#")]),t._v(" let和const(提升/块级作用域/TDZ)")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"symbol和bigint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#symbol和bigint"}},[t._v("#")]),t._v(" symbol和bigint")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"map和set区别-和object区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map和set区别-和object区别"}},[t._v("#")]),t._v(" Map和Set区别？和Object区别？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"weakmap和weakset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#weakmap和weakset"}},[t._v("#")]),t._v(" WeakMap和WeakSet")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"箭头函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" 箭头函数")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"字符串-数组等拓展方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串-数组等拓展方法"}},[t._v("#")]),t._v(" 字符串/数组等拓展方法")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"promise串行和并行及异常处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise串行和并行及异常处理"}},[t._v("#")]),t._v(" Promise串行和并行及异常处理？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"async-awiat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-awiat"}},[t._v("#")]),t._v(" async/awiat")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"proxy和reflect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proxy和reflect"}},[t._v("#")]),t._v(" Proxy和Reflect")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h1",{attrs:{id:"场景题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景题"}},[t._v("#")]),t._v(" 场景题")]),t._v(" "),s("h2",{attrs:{id:"文件上传-拖拽-断点续传-妙传"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件上传-拖拽-断点续传-妙传"}},[t._v("#")]),t._v(" 文件上传(拖拽/断点续传/妙传)")]),t._v(" "),s("h2",{attrs:{id:"无缝轮播图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无缝轮播图"}},[t._v("#")]),t._v(" 无缝轮播图")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("设置2个index，12345 -> 23451-> 34512 -> 45123 -> 51234 -> 12345")]),t._v(" "),s("li",[t._v("多复制一份原有容器的图片数量，到最后一张偏移位置置位0")])])]),s("h2",{attrs:{id:"虚拟滚动-延迟加载如何做-判断一个元素是否在可视区域中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟滚动-延迟加载如何做-判断一个元素是否在可视区域中"}},[t._v("#")]),t._v(" 虚拟滚动，延迟加载如何做？判断一个元素是否在可视区域中")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"获取dom所有节点的数量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#获取dom所有节点的数量"}},[t._v("#")]),t._v(" 获取DOM所有节点的数量")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("p",[s("code",[t._v("document.querySelectorAll('*').length")])])]),s("h2",{attrs:{id:"下拉刷新-加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#下拉刷新-加载"}},[t._v("#")]),t._v(" 下拉刷新/加载")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"单点登录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单点登录"}},[t._v("#")]),t._v(" 单点登录")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("blockquote",[s("p",[t._v("得分情况，在同域名下的单点登录，和不同域名下的单点登录")])]),t._v(" "),s("ul",[s("li",[t._v("认证中心")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);