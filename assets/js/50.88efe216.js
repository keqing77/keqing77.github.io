(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{634:function(t,a,s){"use strict";s.r(a);var e=s(14),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"javascript面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript面试题"}},[t._v("#")]),t._v(" JavaScript面试题")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("本篇主要介绍JS面试题。ES6相关的可能也会放在这里，手撕代码因为篇幅原因单独一篇")]),t._v(" "),s("hr")]),t._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#js有哪些数据类型-区别-存放位置"}},[t._v("JS有哪些数据类型？区别？存放位置？")])]),s("li",[s("a",{attrs:{href:"#判断数据类型的方法有哪些"}},[t._v("判断数据类型的方法有哪些？")])]),s("li",[s("a",{attrs:{href:"#null是对象吗-为什么"}},[t._v("null是对象吗？为什么？")])]),s("li",[s("a",{attrs:{href:"#_0-1-0-2-0-3-浮点数精度问题"}},[t._v("0.1+0.2!=0.3,浮点数精度问题")])]),s("li",[s("a",{attrs:{href:"#number强制转换对象类型返回值"}},[t._v("Number强制转换对象类型返回值？")])]),s("li",[s("a",{attrs:{href:"#_1-tostring-为什么可以调用"}},[t._v("‘1’.toString()为什么可以调用？")])]),s("li",[s("a",{attrs:{href:"#_1-2-3-map-parseint-的结果"}},[t._v("[1,2,3].map(parseInt)的结果？")])]),s("li",[s("a",{attrs:{href:"#和-的区别"}},[t._v("==和===的区别")])]),s("li",[s("a",{attrs:{href:"#object-is和-的区别"}},[t._v("Object.is和===的区别")])]),s("li",[s("a",{attrs:{href:"#js类型转换规则"}},[t._v("JS类型转换规则")])]),s("li",[s("a",{attrs:{href:"#对象类型转原始类型"}},[t._v("对象类型转原始类型")])]),s("li",[s("a",{attrs:{href:"#让if-a-1-a-2-a-3-成立"}},[t._v("让if( a==1 && a==2 && a==3 )成立")])]),s("li",[s("a",{attrs:{href:"#闭包是什么-作用-优缺点"}},[t._v("闭包是什么？作用？优缺点？")])]),s("li",[s("a",{attrs:{href:"#this的绑定规则"}},[t._v("this的绑定规则")])]),s("li",[s("a",{attrs:{href:"#new操作符干了什么"}},[t._v("new操作符干了什么？")])]),s("li",[s("a",{attrs:{href:"#作用域和作用域链"}},[t._v("作用域和作用域链")])]),s("li",[s("a",{attrs:{href:"#原型和原型链"}},[t._v("原型和原型链")])]),s("li",[s("a",{attrs:{href:"#function和object的关系"}},[t._v("Function和Object的关系")])]),s("li",[s("a",{attrs:{href:"#构造函数和原型对象的关系"}},[t._v("构造函数和原型对象的关系")])]),s("li",[s("a",{attrs:{href:"#js同名变量的优先级-函数名-函数参数名-内部变量"}},[t._v("JS同名变量的优先级(函数名，函数参数名，内部变量)")])]),s("li",[s("a",{attrs:{href:"#js实现继承的方法汇总-优缺点分析"}},[t._v("JS实现继承的方法汇总，优缺点分析")])]),s("li",[s("a",{attrs:{href:"#js数组-字符串等方法考察"}},[t._v("JS数组/字符串等方法考察")])]),s("li",[s("a",{attrs:{href:"#深拷贝-浅拷贝-是深拷贝吗"}},[t._v("深拷贝/浅拷贝？...是深拷贝吗？")])]),s("li",[s("a",{attrs:{href:"#模块化"}},[t._v("模块化")])]),s("li",[s("a",{attrs:{href:"#v8引擎如何进行垃圾回收"}},[t._v("V8引擎如何进行垃圾回收？")])]),s("li",[s("a",{attrs:{href:"#事件循环event-loop"}},[t._v("事件循环Event Loop")])]),s("li",[s("a",{attrs:{href:"#异步编程方案-优缺点分析"}},[t._v("异步编程方案？优缺点分析")])]),s("li",[s("a",{attrs:{href:"#事件冒泡-捕获-委托"}},[t._v("事件冒泡/捕获/委托")])]),s("li",[s("a",{attrs:{href:"#跨域-原因和解决"}},[t._v("跨域，原因和解决")])]),s("li",[s("a",{attrs:{href:"#let和const-提升-块级作用域-tdz"}},[t._v("let和const(提升/块级作用域/TDZ)")])]),s("li",[s("a",{attrs:{href:"#symbol和bigint"}},[t._v("symbol和bigint")])]),s("li",[s("a",{attrs:{href:"#map和set区别-和object区别"}},[t._v("Map和Set区别？和Object区别？")])]),s("li",[s("a",{attrs:{href:"#weakmap和weakset"}},[t._v("WeakMap和WeakSet")])]),s("li",[s("a",{attrs:{href:"#箭头函数"}},[t._v("箭头函数")])]),s("li",[s("a",{attrs:{href:"#字符串-数组等拓展方法"}},[t._v("字符串/数组等拓展方法")])]),s("li",[s("a",{attrs:{href:"#promise串行和并行及异常处理"}},[t._v("Promise串行和并行及异常处理？")])]),s("li",[s("a",{attrs:{href:"#async-awiat"}},[t._v("async/awiat")])]),s("li",[s("a",{attrs:{href:"#proxy和reflect"}},[t._v("Proxy和Reflect")])]),s("li",[s("a",{attrs:{href:"#文件上传-拖拽-断点续传-妙传"}},[t._v("文件上传(拖拽/断点续传/妙传)")])]),s("li",[s("a",{attrs:{href:"#无缝轮播图"}},[t._v("无缝轮播图")])]),s("li",[s("a",{attrs:{href:"#虚拟滚动-延迟加载如何做-判断一个元素是否在可视区域中"}},[t._v("虚拟滚动，延迟加载如何做？判断一个元素是否在可视区域中")])]),s("li",[s("a",{attrs:{href:"#获取dom所有节点的数量"}},[t._v("获取DOM所有节点的数量")])]),s("li",[s("a",{attrs:{href:"#下拉刷新-加载"}},[t._v("下拉刷新/加载")])]),s("li",[s("a",{attrs:{href:"#单点登录"}},[t._v("单点登录")])]),s("li",[s("a",{attrs:{href:"#webpack优化"}},[t._v("webpack优化")])]),s("li",[s("a",{attrs:{href:"#面向过程、面向对象oop、函数式编程fp各自区别"}},[t._v("面向过程、面向对象OOP、函数式编程FP各自区别")])])])]),s("p"),t._v(" "),s("h2",{attrs:{id:"js有哪些数据类型-区别-存放位置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js有哪些数据类型-区别-存放位置"}},[t._v("#")]),t._v(" JS有哪些数据类型？区别？存放位置？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("基本类型有七种： null、undefined、boolean、number、string、symbol、bigint")]),t._v(" "),s("li",[t._v("引用类型有一种: object(包含 array,function,date,regexp,map,set,weakmap,weakset)")]),t._v(" "),s("li",[t._v("基本类型值存放在"),s("strong",[t._v("栈")]),t._v("内存中，引用类型值存放在堆中，"),s("strong",[t._v("栈中存放指向堆内存的指针")]),t._v("。")])])]),s("h2",{attrs:{id:"判断数据类型的方法有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#判断数据类型的方法有哪些"}},[t._v("#")]),t._v(" 判断数据类型的方法有哪些？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("typeof (可以判断除了null的基本数据类型，引用类型都返回object)")]),t._v(" "),s("li",[t._v("instanceof (只能判断引用类型都)")]),t._v(" "),s("li",[t._v("Object.prototype.toString (可以判断所有类型)")]),t._v(" "),s("li",[t._v("根据对象的构造器constructor进行判断")]),t._v(" "),s("li",[t._v("Array.isArray (只能判断数组), NaN.isNaN(只能判断NaN)，Number.isInteger() (只能判断整数)")])])]),s("h2",{attrs:{id:"null是对象吗-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#null是对象吗-为什么"}},[t._v("#")]),t._v(" null是对象吗？为什么？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("null是一个基本类型，值为null，不是对象。")]),t._v(" "),s("li",[t._v("typeof null === 'object'，这是一个JS设计的BUG，因为改动会影响底层故保留这个BUG。")])])]),s("h2",{attrs:{id:"_0-1-0-2-0-3-浮点数精度问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2-0-3-浮点数精度问题"}},[t._v("#")]),t._v(" 0.1+0.2!=0.3,浮点数精度问题")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("浮点数 Value = sign  * exponent bias * fraction")]),t._v(" "),s("li",[t._v("JS采用IEEE 754编码，即用64位二进制数表示数字，"),s("strong",[t._v("符号位 sign")]),t._v("1位，"),s("strong",[t._v("指数偏移值exponent bias")]),t._v("11位，剩余的53位"),s("strong",[t._v("fraction")]),t._v("用来表示小数，而像0.1这种小数，转化成二进制是无限循环的，只能保留53位，所以在ES6前，JS最大的数字为2^53-1，即9007199254740991。")]),t._v(" "),s("li",[t._v("JS的number都是浮点型的，可以采用parseFloat((0.1+0.2).toFixed(10)) ===0.3来判断")])])]),s("h2",{attrs:{id:"number强制转换对象类型返回值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#number强制转换对象类型返回值"}},[t._v("#")]),t._v(" Number强制转换对象类型返回值？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"_1-tostring-为什么可以调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-tostring-为什么可以调用"}},[t._v("#")]),t._v(" ‘1’.toString()为什么可以调用？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("原始类型是没有函数可以调用的，但是对象类型有toString方法，所以可以调用。")]),t._v(" "),s("li",[t._v("'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。")])])]),s("h2",{attrs:{id:"_1-2-3-map-parseint-的结果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-map-parseint-的结果"}},[t._v("#")]),t._v(" [1,2,3].map(parseInt)的结果？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("结果是："),s("code",[t._v("[1,NaN,NaN]")])])])]),s("h2",{attrs:{id:"和-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别"}},[t._v("#")]),t._v(" ==和===的区别")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("==判断值是否相等，类型不同会进行隐式类型转换")]),t._v(" "),s("li",[t._v("===判断值和类型是否相等，不会进行类型转换")]),t._v(" "),s("li",[t._v("避免错误尽量使用===")])])]),s("h2",{attrs:{id:"object-is和-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-is和-的区别"}},[t._v("#")]),t._v(" Object.is和===的区别")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("都用于判断两者是否相等，Object.is比三等能多判断 "),s("code",[t._v("NaN")]),t._v(","),s("code",[t._v("+0,-0")]),t._v("的相等")])])]),s("h2",{attrs:{id:"js类型转换规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js类型转换规则"}},[t._v("#")]),t._v(" JS类型转换规则")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("类型转换规则")]),s("ul",[s("li",[t._v("分两种情况 : 1.强制类型转换 2.隐式类型转换")]),t._v(" "),s("li",[t._v("其实就是Number、String、Boolean这三个类型之间的相互转化")]),t._v(" "),s("li",[t._v("内容有点多，后续补充。。")])])]),s("h2",{attrs:{id:"对象类型转原始类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象类型转原始类型"}},[t._v("#")]),t._v(" 对象类型转原始类型")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("对象转基本数据类型会进行以下操作\n"),s("ul",[s("li",[t._v("如果已经为原始数据，不需要转换")]),t._v(" "),s("li",[t._v("调用x.valueOf() 方法，如果转换为基本数据类型，则返回转换的值")]),t._v(" "),s("li",[t._v("调用x.toString()方法 方法，如果转换为基本数据类型，则返回转换的值")])])]),t._v(" "),s("li",[t._v("对象通过Number强行转换为NaN")])])]),s("h2",{attrs:{id:"让if-a-1-a-2-a-3-成立"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#让if-a-1-a-2-a-3-成立"}},[t._v("#")]),t._v(" 让if( a==1 && a==2 && a==3 )成立")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("重写valueOf()方法，读取的时候进行累加操作")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("valueOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])])]),s("h2",{attrs:{id:"闭包是什么-作用-优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包是什么-作用-优缺点"}},[t._v("#")]),t._v(" 闭包是什么？作用？优缺点？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("闭包: 有权访问另一个函数作用域中变量的函数")]),s("blockquote",[s("p",[t._v("函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。")])]),t._v(" "),s("ul",[s("li",[t._v("优点: 保护函数内的变量安全 ，实现封装，防止变量名污染作用域")]),t._v(" "),s("li",[t._v("缺点: 保持着对变量的引用，作用域链得不到释放，容易造成内存泄露")])])]),s("h2",{attrs:{id:"this的绑定规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this的绑定规则"}},[t._v("#")]),t._v(" this的绑定规则")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("this 优先级 new > 显式绑定 (call,apply,bind) > 隐式绑定 (obj.fn()) > 默认绑定 (fn())")]),s("ul",[s("li",[t._v("默认绑定")]),t._v(" "),s("li",[t._v("隐式绑定")]),t._v(" "),s("li",[t._v("显式绑定")]),t._v(" "),s("li",[t._v("new绑定")]),t._v(" "),s("li",[t._v("特殊情况: 1. 箭头函数 2. 严格模式")])])]),s("h2",{attrs:{id:"new操作符干了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new操作符干了什么"}},[t._v("#")]),t._v(" new操作符干了什么？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("new做的四件事情")]),s("ol",[s("li",[t._v("创建一个空的简单JavaScript对象（即{}）；")]),t._v(" "),s("li",[t._v("为步骤1新创建的对象添加属性，将该属性链接至构造函数的原型对象 ；proto")]),t._v(" "),s("li",[t._v("将步骤1新创建的对象作为"),s("strong",[t._v("this")]),t._v("的上下文 ；")]),t._v(" "),s("li",[t._v("如果该函数没有返回对象，则返回"),s("strong",[t._v("this")]),t._v("。")])])]),s("h2",{attrs:{id:"作用域和作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域和作用域链"}},[t._v("#")]),t._v(" 作用域和作用域链")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("作用域和作用域链")]),s("ul",[s("li",[t._v("变量作用的范围叫作作用域")]),t._v(" "),s("li",[t._v("当前作用域不存在的变量和引用，就沿着作用域链继续寻找")])])]),s("h2",{attrs:{id:"原型和原型链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[t._v("#")]),t._v(" 原型和原型链")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("原型和原型链")]),s("ul",[s("li",[t._v("新建一个对象，会发现除了自己添加的还有很多属性，这些都是从原型上继承下来的")]),t._v(" "),s("li",[t._v("每个 JS 对象都有 "),s("strong",[t._v("proto")]),t._v(" 属性(浏览器实现，非标准)，这个属性指向了原型，实例对象."),s("strong",[t._v("proto")]),t._v(" === 原型对象.constructor")]),t._v(" "),s("li",[t._v("当在实例对象上找不到时，就会去原型上找，原型也有自己的原型，查找的过程就形成一条了原型链。")])])]),s("h2",{attrs:{id:"function和object的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function和object的关系"}},[t._v("#")]),t._v(" Function和Object的关系")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("Object 是所有对象的底层原型，所有对象都可以通过 "),s("strong",[t._v("proto")]),t._v(" 找到它")]),t._v(" "),s("li",[t._v("Function 是所有函数的顶层爸爸，所有函数都可以通过 "),s("strong",[t._v("proto")]),t._v(" 找到它")]),t._v(" "),s("li",[t._v("函数的 prototype 是一个对象")])])]),s("h2",{attrs:{id:"构造函数和原型对象的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数和原型对象的关系"}},[t._v("#")]),t._v(" 构造函数和原型对象的关系")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("在new关键词后面的函数就是 构造函数")]),t._v(" "),s("li",[t._v("原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型")])])]),s("h2",{attrs:{id:"js同名变量的优先级-函数名-函数参数名-内部变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js同名变量的优先级-函数名-函数参数名-内部变量"}},[t._v("#")]),t._v(" JS同名变量的优先级(函数名，函数参数名，内部变量)")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("函数形参可以看做是函数的局部变量，如果形参赋值，则()是一个单独的作用域，外层作用域是函数的作用域")]),t._v(" "),s("li",[t._v("函数名会覆盖形参名，变量名不会")])])]),s("h2",{attrs:{id:"js实现继承的方法汇总-优缺点分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js实现继承的方法汇总-优缺点分析"}},[t._v("#")]),t._v(" JS实现继承的方法汇总，优缺点分析")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ol",[s("li",[t._v("构造函数继承")]),t._v(" "),s("li",[t._v("原型继承")]),t._v(" "),s("li",[t._v("组合继承")]),t._v(" "),s("li",[t._v("寄生组合继承")]),t._v(" "),s("li",[t._v("圣杯继承")]),t._v(" "),s("li",[t._v("class继承(语法糖)")])])]),s("h2",{attrs:{id:"js数组-字符串等方法考察"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js数组-字符串等方法考察"}},[t._v("#")]),t._v(" JS数组/字符串等方法考察")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("会改变数组自身的七个方法: pop push shift unshift reverse sort splice")]),t._v(" "),s("li",[t._v("...后续更新")])])]),s("h2",{attrs:{id:"深拷贝-浅拷贝-是深拷贝吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝-浅拷贝-是深拷贝吗"}},[t._v("#")]),t._v(" 深拷贝/浅拷贝？...是深拷贝吗？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("深浅拷贝")]),s("ul",[s("li",[t._v("就是拷贝的层级，只能拷贝第一次则是浅拷贝，嵌套层级也能拷则是深拷贝(或者拷贝的数据是否和源对象共享)")]),t._v(" "),s("li",[t._v("除了深拷贝(1.JSON.parse(JSON.stringify() 2.手写深拷贝)) 都是浅拷贝")]),t._v(" "),s("li",[t._v("浅拷贝(1. ...拓展运算符 2.array.map 3. array.concat 4.Object.assign()等等都是)")])])]),s("h2",{attrs:{id:"模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[t._v("#")]),t._v(" 模块化")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("模块化")]),s("ul",[s("li",[t._v("防止命名冲突")]),t._v(" "),s("li",[t._v("可复用代码")]),t._v(" "),s("li",[t._v("拆分成不同模块方便维护")])]),t._v(" "),s("blockquote",[s("p",[t._v("模块化方案:")])]),t._v(" "),s("ul",[s("li",[t._v("AMD 和 CMD(历史方案)")]),t._v(" "),s("li",[t._v("CommonJS(node.js专用，不属于JS规范)")]),t._v(" "),s("li",[t._v("Esmodule(js原生实现的模块化方案)")])])]),s("h2",{attrs:{id:"v8引擎如何进行垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎如何进行垃圾回收"}},[t._v("#")]),t._v(" V8引擎如何进行垃圾回收？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("p",[t._v("这个有点复杂,至今还未完全理解")]),t._v(" "),s("ul",[s("li",[t._v("标记清除算法")]),t._v(" "),s("li",[t._v("标记压缩算法")])])]),s("h2",{attrs:{id:"事件循环event-loop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件循环event-loop"}},[t._v("#")]),t._v(" 事件循环Event Loop")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ol",[s("li",[t._v("执⾏同步代码，这属于宏任务")]),t._v(" "),s("li",[t._v("执⾏栈为空，查询是否有微任务需要执⾏")]),t._v(" "),s("li",[t._v("执⾏所有微任务")]),t._v(" "),s("li",[t._v("必要的话渲染 UI")]),t._v(" "),s("li",[t._v("然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码")])])]),s("h2",{attrs:{id:"异步编程方案-优缺点分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步编程方案-优缺点分析"}},[t._v("#")]),t._v(" 异步编程方案？优缺点分析")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ol",[s("li",[t._v("回调函数")]),t._v(" "),s("li",[t._v("Promise")]),t._v(" "),s("li",[t._v("Generator")]),t._v(" "),s("li",[t._v("async/await")])])]),s("h2",{attrs:{id:"事件冒泡-捕获-委托"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡-捕获-委托"}},[t._v("#")]),t._v(" 事件冒泡/捕获/委托")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("blockquote",[s("p",[t._v("这些是浏览器的事件机制")])]),t._v(" "),s("ol",[s("li",[t._v("事件冒泡是从里到外依次触发")]),t._v(" "),s("li",[t._v("事件捕获是从外到里依次触发")]),t._v(" "),s("li",[t._v("事件委托利用的事件冒泡机制")])])]),s("h2",{attrs:{id:"跨域-原因和解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨域-原因和解决"}},[t._v("#")]),t._v(" 跨域，原因和解决")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("p",[s("strong",[t._v("跨域是由于浏览器的同源策略")])]),t._v(" "),s("blockquote",[s("p",[t._v("同源策略")])]),t._v(" "),s("ul",[s("li",[t._v("域名、协议、端口号要一致，否则ajax请求失败")])]),t._v(" "),s("blockquote",[s("p",[t._v("为什么要有同源策略？")])]),t._v(" "),s("ul",[s("li",[t._v("只有"),s("strong",[t._v("浏览器")]),t._v("才会存在跨域,服务器或者小程序这些是不存在跨域的。")]),t._v(" "),s("li",[t._v("是出于安全考虑，没有同源策略限制，你网站的cookie就会被任意来源的ajax获取，泄露信息。")])]),t._v(" "),s("blockquote",[s("p",[t._v("跨域解决方案")])]),t._v(" "),s("ul",[s("li",[t._v("jsonp")]),t._v(" "),s("li",[t._v("cors")]),t._v(" "),s("li",[t._v("node.js正向代理")]),t._v(" "),s("li",[t._v("nginx反向代理")]),t._v(" "),s("li",[t._v("webpack/vite/axios 配置 proxy")]),t._v(" "),s("li",[t._v("websocket(本身不存在跨域限制)")]),t._v(" "),s("li",[t._v("iframe + windows.postmessage")]),t._v(" "),s("li",[t._v("iframe + windows.document.domain\n")]),t._v(" "),s("li",[t._v("浏览器开启跨域，不推荐")])])]),s("h1",{attrs:{id:"es6考察"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6考察"}},[t._v("#")]),t._v(" es6考察")]),t._v(" "),s("h2",{attrs:{id:"let和const-提升-块级作用域-tdz"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#let和const-提升-块级作用域-tdz"}},[t._v("#")]),t._v(" let和const(提升/块级作用域/TDZ)")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"symbol和bigint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#symbol和bigint"}},[t._v("#")]),t._v(" symbol和bigint")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"map和set区别-和object区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map和set区别-和object区别"}},[t._v("#")]),t._v(" Map和Set区别？和Object区别？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"weakmap和weakset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#weakmap和weakset"}},[t._v("#")]),t._v(" WeakMap和WeakSet")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("其中的键是弱引用的,其键key必须是对象，而值value可以是任意的。")]),t._v(" "),s("li",[t._v("原生的 WeakMap 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。")]),t._v(" "),s("li",[t._v("正由于这样的弱引用，WeakMap 的 key 是不可枚举的")])])]),s("h2",{attrs:{id:"箭头函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" 箭头函数")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("没有argument，没有构造函数，不能new")]),t._v(" "),s("li",[t._v("没有自己的this，this继承外层普通函数function，this指向不会改变")])])]),s("h2",{attrs:{id:"字符串-数组等拓展方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串-数组等拓展方法"}},[t._v("#")]),t._v(" 字符串/数组等拓展方法")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("这个太多了")])])]),s("h2",{attrs:{id:"promise串行和并行及异常处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise串行和并行及异常处理"}},[t._v("#")]),t._v(" Promise串行和并行及异常处理？")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("blockquote",[s("p",[t._v("串行:  promise.then() 链式操作\n并行: promise.all()")])])]),s("h2",{attrs:{id:"async-awiat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-awiat"}},[t._v("#")]),t._v(" async/awiat")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("blockquote",[s("p",[t._v("async")])]),t._v(" "),s("ul",[s("li",[t._v("⼀个函数如果加上 async ，那么该函数就会返回⼀个 Promise")])]),t._v(" "),s("blockquote",[s("p",[t._v("await")])]),t._v(" "),s("ul",[s("li",[t._v("await 只能在 async 函数中使⽤")]),t._v(" "),s("li",[t._v("await下面的代码可以看做是promise.then()")])])]),s("h2",{attrs:{id:"proxy和reflect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proxy和reflect"}},[t._v("#")]),t._v(" Proxy和Reflect")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h1",{attrs:{id:"场景题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景题"}},[t._v("#")]),t._v(" 场景题")]),t._v(" "),s("h2",{attrs:{id:"文件上传-拖拽-断点续传-妙传"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件上传-拖拽-断点续传-妙传"}},[t._v("#")]),t._v(" 文件上传(拖拽/断点续传/妙传)")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("获取文件对象 转换成二进制(blob/stream/buffer)")]),t._v(" "),s("li",[t._v("拖拽API")]),t._v(" "),s("li",[t._v("状态码206分片上传断点续传")])])]),s("h2",{attrs:{id:"无缝轮播图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无缝轮播图"}},[t._v("#")]),t._v(" 无缝轮播图")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("ul",[s("li",[t._v("设置2个index，12345 -> 23451-> 34512 -> 45123 -> 51234 -> 12345")]),t._v(" "),s("li",[t._v("多复制一份原有容器的图片数量，到最后一张偏移位置置位0")]),t._v(" "),s("li",[t._v("用swiper插件🤣")])])]),s("h2",{attrs:{id:"虚拟滚动-延迟加载如何做-判断一个元素是否在可视区域中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟滚动-延迟加载如何做-判断一个元素是否在可视区域中"}},[t._v("#")]),t._v(" 虚拟滚动，延迟加载如何做？判断一个元素是否在可视区域中")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("blockquote",[s("p",[t._v("懒加载就是将不关键的资源延后加载。")])]),t._v(" "),s("p",[t._v("原理就是只加载页面的可视区域，不断动态替换页面可视区域的DOM节点。")]),t._v(" "),s("ul",[s("li",[t._v("对于图片来说，src属性可以先给个小体积的，真正的图片地址用自定义属性data-url存储，当图片出现在可视区域的时候才去下载真正地图片，实现了图片懒加载。")]),t._v(" "),s("li",[t._v("懒加载除了用在图片，也可以使用在其他资源。比如进入可视区域才开始播放视频等等。")])])]),s("h2",{attrs:{id:"获取dom所有节点的数量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#获取dom所有节点的数量"}},[t._v("#")]),t._v(" 获取DOM所有节点的数量")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("p",[s("code",[t._v("document.querySelectorAll('*').length")])])]),s("h2",{attrs:{id:"下拉刷新-加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#下拉刷新-加载"}},[t._v("#")]),t._v(" 下拉刷新/加载")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")])]),s("h2",{attrs:{id:"单点登录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单点登录"}},[t._v("#")]),t._v(" 单点登录")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("THEOREM")]),s("blockquote",[s("p",[t._v("得分情况，在同域名下的单点登录，和不同域名下的单点登录")])]),t._v(" "),s("ul",[s("li",[t._v("认证中心")])])]),s("h2",{attrs:{id:"webpack优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack优化"}},[t._v("#")]),t._v(" webpack优化")]),t._v(" "),s("div",{staticClass:"theorem"},[s("p",{staticClass:"title"},[t._v("webpack")]),s("ul",[s("li",[t._v("优化 Loader 的文件搜索范围")]),t._v(" "),s("li",[t._v("Loader已经编译过的代码不改变直接缓存起来")]),t._v(" "),s("li",[t._v("代码压缩")]),t._v(" "),s("li",[t._v("按需加载")]),t._v(" "),s("li",[t._v("Tree Shaking(需要ESmodule支持)")])])]),s("h2",{attrs:{id:"面向过程、面向对象oop、函数式编程fp各自区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向过程、面向对象oop、函数式编程fp各自区别"}},[t._v("#")]),t._v(" 面向过程、面向对象OOP、函数式编程FP各自区别")]),t._v(" "),s("blockquote",[s("p",[t._v("面向过程 (Procedure-Oriented Programming)\n代表语言: C / Golang\n面向对象 (Object Oriented Programming)\n代表语言: C++ / C# / Java / Python / Golang\n函数式编程 (Function Programming)\n代表语言: Lisp,JS,Rust")])]),t._v(" "),s("p",[t._v(":: theorem 编程方式区别")]),t._v(" "),s("ul",[s("li",[t._v("程序本质就是操作数据，oop和fp都把数据封装到属性中，")]),t._v(" "),s("li",[t._v("oop通过对象封装和操作属性。fp通过函数来操作属性")]),t._v(" "),s("li",[t._v("函数式编程对开发者要求更高一些，需要对程序的理解更深入。面向对象则更浅显，所以为了让公司里面良莠不齐的开发人员统一协作，就逐渐采用了以面向对象为主的开发模式。\n:::")])])])}),[],!1,null,null,null);a.default=v.exports}}]);