(window.webpackJsonp=window.webpackJsonp||[]).push([[185],{728:function(e,t,a){"use strict";a.r(t);var v=a(13),l=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"vite"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[e._v("#")]),e._v(" Vite")]),e._v(" "),a("p",[e._v("未完待续...")]),e._v(" "),a("p",[e._v("Vite.config.js")]),e._v(" "),a("h2",{attrs:{id:"vue的性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的性能优化"}},[e._v("#")]),e._v(" Vue的性能优化")]),e._v(" "),a("p",[e._v("Vue的设计非常优秀，这导致Vue在三大框架中的性能表现是最好的。足以应对大部分场景的性能需求，然而在某些复杂场景下，还是需要自己来手动优化的。其实也无非几点")]),e._v(" "),a("ul",[a("li",[e._v("包体积与 Tree-shaking 优化，减少包体积，剔除掉没有用到的模块")]),e._v(" "),a("li",[e._v("代码拆分，构建工具将应用程序包拆分为多个较小的块，然后可以按需或并行加载。通过适当的代码拆分，页面加载时需要的功能可以立即下载，而额外的块只在需要时才加载")]),e._v(" "),a("li",[e._v("异步组件 路由懒加载")]),e._v(" "),a("li",[e._v("SSR/SSG")]),e._v(" "),a("li",[e._v("渲染大型列表，列表虚拟化")]),e._v(" "),a("li",[e._v("减少不必要深响应式开销")])]),e._v(" "),a("h2",{attrs:{id:"shallowref和shallowreactive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shallowref和shallowreactive"}},[e._v("#")]),e._v(" shallowRef和shallowReactive")]),e._v(" "),a("p",[e._v("Vue 的响应性系统默认是深度的。虽然这让状态管理变得更直观，但在数据变大时它也的确创造了不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。试想一下当一次渲染需要访问 100,000+ 属性的时候，这个开销在处理大型数组或层级很深的对象时变得无法忽略，因此，我们应该控制它只影响非常具体的使用情况。")]),e._v(" "),a("p",[e._v("Vue 确实也为此提供了一种解决方案，通过使用 shallowRef() 和 shallowReactive() 来选择退出深度响应")])])}),[],!1,null,null,null);t.default=l.exports}}]);