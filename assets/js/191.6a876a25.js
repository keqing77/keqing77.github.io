(window.webpackJsonp=window.webpackJsonp||[]).push([[191],{800:function(a,t,e){"use strict";e.r(t);var l=e(14),s=Object(l.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"vite"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[a._v("#")]),a._v(" Vite")]),a._v(" "),e("p",[e("RouterLink",{attrs:{to:"/guide/notes/tool/02-Vite.html"}},[a._v("Vite看这里")])],1),a._v(" "),e("h2",{attrs:{id:"vue3性能提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3性能提升"}},[a._v("#")]),a._v(" Vue3性能提升")]),a._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[a._v("Vue性能优化")]),e("p",[a._v("Vue的设计非常优秀，这导致Vue在三大框架中的性能表现是最好的。足以应对大部分场景的性能需求，然而在某些复杂场景下，还是需要自己来手动优化的。其实也无非几点")]),a._v(" "),e("ul",[e("li",[a._v("压缩包体积与 Tree-shaking，webpack/gzip减少包体积，剔除掉没有用到的模块")]),a._v(" "),e("li",[a._v("代码拆分，构建工具将应用程序包拆分为多个较小的块，然后可以按需或并行加载。通过适当的代码拆分，页面加载时需要的功能可以立即下载，而额外的块只在需要时才加载")]),a._v(" "),e("li",[a._v("异步组件 路由懒加载")]),a._v(" "),e("li",[a._v("SSR/SSG")]),a._v(" "),e("li",[a._v("渲染大型列表，列表虚拟化,需要虚拟滚动插件")]),a._v(" "),e("li",[a._v("减少不必要深响应式开销(shallowRef和shallowReactive)")]),a._v(" "),e("li",[a._v("组件UI库/插件 按需引入")])])]),e("h3",{attrs:{id:"静态提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态提升"}},[a._v("#")]),a._v(" 静态提升")]),a._v(" "),e("ul",[e("li",[a._v("Vue2中无论元素是否参与更新, 每次都会重新创建, 然后再渲染")]),a._v(" "),e("li",[a._v("Vue3中对于不参与更新的元素, 会做静态提升, 只会被创建一次, 在渲染时直接复用即可")])]),a._v(" "),e("h3",{attrs:{id:"diff优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff优化"}},[a._v("#")]),a._v(" diff优化")]),a._v(" "),e("ul",[e("li",[a._v("Vue2 中的虚拟dom是进行全量的对比")]),a._v(" "),e("li",[a._v("Vue3 新增了静态标记（PatchFlag），只比对带有 PF 的节点，并且通过 Flag 的信息得知 当前节点要比对的具体内容\n同时diff算法和响应式系统解耦，")])]),a._v(" "),e("h3",{attrs:{id:"cachehandlers-事件侦听器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cachehandlers-事件侦听器缓存"}},[a._v("#")]),a._v(" cacheHandlers 事件侦听器缓存")]),a._v(" "),e("ul",[e("li",[a._v("默认情况下onClick会被视为动态绑定, 所以每次都会去追踪它的变化")]),a._v(" "),e("li",[a._v("但是因为是同一个函数，所以没有追踪变化, 直接缓存起来复用即可")])]),a._v(" "),e("h3",{attrs:{id:"去除响应式-shallowref和shallowreactive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#去除响应式-shallowref和shallowreactive"}},[a._v("#")]),a._v(" 去除响应式(shallowRef和shallowReactive)")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("Vue 的响应性系统默认是深度的。虽然这让状态管理变得更直观，但在数据变大时它也的确创造了不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。试想一下当一次渲染需要访问 100,000+ 属性的时候，这个开销在处理大型数组或层级很深的对象时变得无法忽略，因此，我们应该控制它只影响非常具体的使用情况。")])]),a._v(" "),e("li",[e("p",[a._v("Vue 确实也为此提供了一种解决方案，通过使用 shallowRef() 和 shallowReactive() 来选择退出深度响应")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);