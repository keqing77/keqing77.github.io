(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{485:function(t,s,a){t.exports=a.p+"assets/img/thread.96065c97.png"},539:function(t,s,a){"use strict";a.r(s);var v=a(13),e=Object(v.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"浏览器进程和线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器进程和线程"}},[t._v("#")]),t._v(" 浏览器进程和线程")]),t._v(" "),v("h2",{attrs:{id:"进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[t._v("#")]),t._v(" 进程")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("什么是进程?")]),t._v(" "),v("p",[t._v("一个进程就是一个程序的运行实例，具体就是启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的运行环境叫进程，"),v("strong",[t._v("进程是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体")]),t._v("。")])]),t._v(" "),v("blockquote",[v("p",[t._v("我们这里将进程比喻为工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。")])]),t._v(" "),v("h2",{attrs:{id:"线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("什么是线程?")]),t._v(" "),v("p",[t._v("任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元。\n"),v("strong",[t._v("进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位")]),t._v("。多线程可以并行处理任务，但是线程是不能单独存在的，需要进程来启动和管理。")])]),t._v(" "),v("blockquote",[v("p",[t._v("这里把线程比喻一个车间的工人，即一个车间可以允许由多个工人协同完成一个任务。")])]),t._v(" "),v("h2",{attrs:{id:"两者关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两者关系"}},[t._v("#")]),t._v(" 两者关系")]),t._v(" "),v("p",[t._v("进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。\n一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；\n进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。\n调度和切换：线程上下文切换比进程上下文切换要快得多。")]),t._v(" "),v("h2",{attrs:{id:"浏览器是多进程的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器是多进程的"}},[t._v("#")]),t._v(" 浏览器是多进程的")]),t._v(" "),v("div",{staticClass:"custom-block danger"},[v("p",{staticClass:"custom-block-title"},[t._v("简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。")]),t._v(" "),v("p",[t._v("浏览器是多进程的，浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）")])]),t._v(" "),v("p",[t._v("浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为\n页面渲染，脚本执行，事件处理等")]),t._v(" "),v("h2",{attrs:{id:"浏览器内核-渲染进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核-渲染进程"}},[t._v("#")]),t._v(" 浏览器内核（渲染进程）")]),t._v(" "),v("p",[v("img",{attrs:{src:a(485),alt:""}})]),t._v(" "),v("blockquote",[v("p",[t._v("请牢记，浏览器的渲染进程是多线程的")])]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("GUI 渲染线程")]),v("br"),t._v("\n负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\n当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\n注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("JS 引擎线程")]),v("br"),t._v("\n也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）\nJS引擎线程负责解析Javascript脚本，运行代码。\nJS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\n同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("事件触发线程")]),v("br"),t._v("\n归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）\n当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中\n当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理\n注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("定时触发器线程")]),v("br"),t._v("\n传说中的setInterval与setTimeout所在线程\n浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\n注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("异步 http 请求线程")]),v("br"),t._v("\n在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。")])])]),t._v(" "),v("h2",{attrs:{id:"浏览器存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器存储"}},[t._v("#")]),t._v(" 浏览器存储")]),t._v(" "),v("ul",[v("li",[t._v("cookie")]),t._v(" "),v("li",[t._v("session")]),t._v(" "),v("li",[t._v("local storage")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("cookie")]),t._v(" "),v("p",[t._v("在处理 HTTP 请求时，服务器可以在 HTTP 响应头中通过HTTP Headers Set-Cookie 为客户端设置  cookie。然后，对于同一服务器发起的每一个请求，客户端都会在 HTTP 请求头中以字段 Cookie 的形式将 cookie 的值发送过去。也可以将 cookie 设置为在特定日期过期，或限制为特定的域和路径。")])]),t._v(" "),v("h2",{attrs:{id:"浏览器事件机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器事件机制"}},[t._v("#")]),t._v(" 浏览器事件机制")]),t._v(" "),v("h3",{attrs:{id:"事件触发的三个阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件触发的三个阶段"}},[t._v("#")]),t._v(" 事件触发的三个阶段")]),t._v(" "),v("ul",[v("li",[t._v("window 往事件触发处传播，遇到注册的捕获事件会触发")]),t._v(" "),v("li",[t._v("传播到事件触发处时触发注册的事件")]),t._v(" "),v("li",[t._v("从事件触发处往 window 传播，遇到注册的冒泡事件会触发")])]),t._v(" "),v("h3",{attrs:{id:"注册事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注册事件"}},[t._v("#")]),t._v(" 注册事件")]),t._v(" "),v("p",[t._v("EventTarget.addEventListener() 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 Element,Document和Window或者任何其他支持事件的对象 (比如 XMLHttpRequest)。")]),t._v(" "),v("div",{staticClass:"language-js line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[t._v("target"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("type"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" listener"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("h3",{attrs:{id:"事件冒泡、捕获、委托"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡、捕获、委托"}},[t._v("#")]),t._v(" 事件冒泡、捕获、委托")]),t._v(" "),v("p",[t._v("后续更新...")]),t._v(" "),v("h2",{attrs:{id:"浏览器的同源机制-跨域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的同源机制-跨域"}},[t._v("#")]),t._v(" 浏览器的同源机制(跨域)")]),t._v(" "),v("p",[v("strong",[t._v("浏览器")]),t._v("出于安全考虑，制订了同源策略。")]),t._v(" "),v("blockquote",[v("p",[t._v("为什么要有同源策略呢，不同源的数据和资源（如HTTP头、Cookie、DOM、localStorage等）前端就能相互随意访问，根本没有隐私和安全可言。")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("同源策略")]),t._v(" "),v("p",[t._v("协议、域名或者端口有一个不同就是跨域，网络请求会因为同源策略被拦截，如ajax、fetch")])]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("跨域")]),t._v(" "),v("ol",[v("li",[t._v("jsonp")]),t._v(" "),v("li",[t._v("CORS")]),t._v(" "),v("li",[t._v("node中间件")]),t._v(" "),v("li",[t._v("nginx反向代理")]),t._v(" "),v("li",[t._v("document.domain")]),t._v(" "),v("li",[t._v("iframe")]),t._v(" "),v("li",[t._v("postmessage")]),t._v(" "),v("li",[t._v("....")])])]),t._v(" "),v("p",[t._v("后续更新...")])])}),[],!1,null,null,null);s.default=e.exports}}]);