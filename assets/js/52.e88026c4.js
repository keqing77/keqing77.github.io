(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{636:function(t,a,e){"use strict";e.r(a);var s=e(14),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vue3面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3面试题"}},[t._v("#")]),t._v(" Vue3面试题")]),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#compositionapi和optionsapi的区别"}},[t._v("CompositionAPI和OptionsApi的区别?")])]),e("li",[e("a",{attrs:{href:"#watcheffect和watch的区别"}},[t._v("WatchEffect和Watch的区别?")])]),e("li",[e("a",{attrs:{href:"#解构的对象如何保持响应式"}},[t._v("解构的对象如何保持响应式?")])]),e("li",[e("a",{attrs:{href:"#vue3-0性能提升主要是通过哪几方面体现的"}},[t._v("Vue3.0性能提升主要是通过哪几方面体现的？")])]),e("li",[e("a",{attrs:{href:"#vue3-0里为什么要用-proxy-api-替代-defineproperty-api"}},[t._v("Vue3.0里为什么要用 Proxy API 替代 defineProperty API")])]),e("li",[e("a",{attrs:{href:"#说说vue-3-0中treeshaking特性-举例说明一下"}},[t._v("说说Vue 3.0中Treeshaking特性？举例说明一下？")])]),e("li",[e("a",{attrs:{href:"#vite快在哪里"}},[t._v("Vite快在哪里？")])]),e("li",[e("a",{attrs:{href:"#vue3性能监控"}},[t._v("Vue3性能监控")])]),e("li",[e("a",{attrs:{href:"#有了解suspense组件吗"}},[t._v("有了解suspense组件吗?")])]),e("li",[e("a",{attrs:{href:"#typescript数据类型有哪些"}},[t._v("TypeScript数据类型有哪些?")])]),e("li",[e("a",{attrs:{href:"#ts类型推导"}},[t._v("TS类型推导")])]),e("li",[e("a",{attrs:{href:"#ts类型断言-as"}},[t._v("TS类型断言(as)")])]),e("li",[e("a",{attrs:{href:"#枚举类型-应用场景"}},[t._v("枚举类型?应用场景?")])]),e("li",[e("a",{attrs:{href:"#类型别名-type-和接口-interface-的区别"}},[t._v("类型别名(type)和接口(interface)的区别")])]),e("li",[e("a",{attrs:{href:"#装饰器的理解-应用场景"}},[t._v("装饰器的理解,应用场景?")])]),e("li",[e("a",{attrs:{href:"#泛型的运用"}},[t._v("泛型的运用")])])])]),e("p"),t._v(" "),e("h2",{attrs:{id:"compositionapi和optionsapi的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#compositionapi和optionsapi的区别"}},[t._v("#")]),t._v(" CompositionAPI和OptionsApi的区别?")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("CompositionAPI")]),e("ul",[e("li",[t._v("CompositionAPI组织代码更加集中，不会optionsAPI那么分散")]),t._v(" "),e("li",[t._v("能更方便的抽取公共逻辑，复用代码")])])]),e("h2",{attrs:{id:"watcheffect和watch的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watcheffect和watch的区别"}},[t._v("#")]),t._v(" WatchEffect和Watch的区别?")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")])]),e("h2",{attrs:{id:"解构的对象如何保持响应式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解构的对象如何保持响应式"}},[t._v("#")]),t._v(" 解构的对象如何保持响应式?")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("Vue3的响应式是用Proxy去做的，解构后的Proxy对象会失去响应式")]),t._v(" "),e("li",[t._v("toRefs")])])]),e("h2",{attrs:{id:"vue3-0性能提升主要是通过哪几方面体现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0性能提升主要是通过哪几方面体现的"}},[t._v("#")]),t._v(" Vue3.0性能提升主要是通过哪几方面体现的？")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("diff的优化(预编译 + flag标记)")]),t._v(" "),e("li",[t._v("tree-shaking(没有用到的代码自动剔除)")]),t._v(" "),e("li",[t._v("响应式解耦")])])]),e("h2",{attrs:{id:"vue3-0里为什么要用-proxy-api-替代-defineproperty-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0里为什么要用-proxy-api-替代-defineproperty-api"}},[t._v("#")]),t._v(" Vue3.0里为什么要用 Proxy API 替代 defineProperty API")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("Vue2的响应式无法监听对象/数组的 动态改变，必须在data中存在去遍历劫持对象的属性，而Proxy直接劫持整个对象，可以有13种拦截对象的方法。")])])]),e("h2",{attrs:{id:"说说vue-3-0中treeshaking特性-举例说明一下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说说vue-3-0中treeshaking特性-举例说明一下"}},[t._v("#")]),t._v(" 说说Vue 3.0中Treeshaking特性？举例说明一下？")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("需要使用ESmodule(import 、export)")]),t._v(" "),e("li",[t._v("比如你使用Vue，但是在你的项目中没有使用v-model，keep-alive这些 api或者指令，关于这些的代码打包就不会被打包进去")])])]),e("h2",{attrs:{id:"vite快在哪里"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vite快在哪里"}},[t._v("#")]),t._v(" Vite快在哪里？")]),t._v(" "),e("ul",[e("li",[t._v("Vite主要快在开发阶段的 1. 启动项目快 2. 热更新快,因为Vite开发阶段是基于esbuild的,Go写的一个打包比JS快上一个数量级,而生产阶段是使用roll up,相比webpack也并没有快多少.")]),t._v(" "),e("li",[t._v("在Webpack中,当模块达到几十个以上的时候,修改其中之一的模块,都需要全部去打包一边再让服务器请求,在项目变得越来越大的时候需要非常长的时间,而Vite会让浏览器做更多的事情,怎么做呢? Webpack是先打包再服务器去请求,而Vite直接不打包了")]),t._v(" "),e("li",[t._v("(快是有前提的,要采用esbuild,import的导入方式)Vite会先启动开发服务器,对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理,浏览器只会对用到的模块发起 HTTP 请求,Vite也只会编译浏览器发起 HTTP 请求的模块,实现了按需加载。")])]),t._v(" "),e("h2",{attrs:{id:"vue3性能监控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3性能监控"}},[t._v("#")]),t._v(" Vue3性能监控")]),t._v(" "),e("ul",[e("li",[t._v("对于性能监控来说，其实我们只需要调用"),e("code",[t._v("performance.getEntriesByType('navigation')")]),t._v(",，一行代码我们就可以获得页面中各种详细的性能相关信息.")])]),t._v(" "),e("h2",{attrs:{id:"有了解suspense组件吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有了解suspense组件吗"}},[t._v("#")]),t._v(" 有了解suspense组件吗?")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("就是组件还没完全加载完成的过渡动画展示组件")]),t._v(" "),e("li",[t._v("可以做 加载动画loading，骨架屏skeleton这些")])])]),e("h1",{attrs:{id:"ts面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ts面试题"}},[t._v("#")]),t._v(" TS面试题")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("现在还在学习中 记录下学习资源")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://www.typescriptlang.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript官方文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript刷题"),e("OutboundLink")],1)])])]),t._v(" "),e("h2",{attrs:{id:"typescript数据类型有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typescript数据类型有哪些"}},[t._v("#")]),t._v(" TypeScript数据类型有哪些?")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("js有的都有，多了any、unknown、void、never、联合类型、泛型等")])])]),e("h2",{attrs:{id:"ts类型推导"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ts类型推导"}},[t._v("#")]),t._v(" TS类型推导")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("TS会根据声明时第一次赋值的类型自动推导变量类型")]),t._v(" "),e("li",[t._v("不赋值的话默认any类型")])])]),e("h2",{attrs:{id:"ts类型断言-as"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ts类型断言-as"}},[t._v("#")]),t._v(" TS类型断言(as)")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("你很确定某个联合类型的类型为某个类型时候就可以用 "),e("code",[t._v("as")]),t._v(" 指定类型")])])]),e("h2",{attrs:{id:"枚举类型-应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#枚举类型-应用场景"}},[t._v("#")]),t._v(" 枚举类型?应用场景?")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("enum")]),t._v(" "),e("li",[t._v("类似性别(男、女、未知)")])])]),e("h2",{attrs:{id:"类型别名-type-和接口-interface-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型别名-type-和接口-interface-的区别"}},[t._v("#")]),t._v(" 类型别名(type)和接口(interface)的区别")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")])]),e("h2",{attrs:{id:"装饰器的理解-应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#装饰器的理解-应用场景"}},[t._v("#")]),t._v(" 装饰器的理解,应用场景?")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("decortor")])])]),e("h2",{attrs:{id:"泛型的运用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型的运用"}},[t._v("#")]),t._v(" 泛型的运用")]),t._v(" "),e("div",{staticClass:"theorem"},[e("p",{staticClass:"title"},[t._v("THEOREM")]),e("ul",[e("li",[t._v("函数的输出类型根据参数的输入类型去推断")])])])])}),[],!1,null,null,null);a.default=i.exports}}]);