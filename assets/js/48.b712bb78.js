(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{620:function(t,s,a){"use strict";a.r(s);var e=a(14),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue2面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2面试题"}},[t._v("#")]),t._v(" Vue2面试题")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#vue目录结构"}},[t._v("Vue目录结构")])]),a("li",[a("a",{attrs:{href:"#什么是spa-单页面应用"}},[t._v("什么是SPA(单页面应用)")])]),a("li",[a("a",{attrs:{href:"#csr-client-side-rendering"}},[t._v("CSR(Client-Side-Rendering)")])]),a("li",[a("a",{attrs:{href:"#什么是ssr-服务端渲染-优缺点"}},[t._v("什么是SSR(服务端渲染),优缺点?")])]),a("li",[a("a",{attrs:{href:"#vue2生命周期-全"}},[t._v("Vue2生命周期(全)")])]),a("li",[a("a",{attrs:{href:"#为什么说vue是单向数据流"}},[t._v("为什么说Vue是单向数据流？")])]),a("li",[a("a",{attrs:{href:"#组件中的data为什么是一个函数"}},[t._v("组件中的data为什么是一个函数？")])]),a("li",[a("a",{attrs:{href:"#组件中的data什么时候可以使用对象"}},[t._v("组件中的data什么时候可以使用对象?")])]),a("li",[a("a",{attrs:{href:"#v-if和v-show有什么区别"}},[t._v("v-if和v-show有什么区别？")])]),a("li",[a("a",{attrs:{href:"#v-if和v-for一起使用会有什么问题-如何解决"}},[t._v("v-if和v-for一起使用会有什么问题？如何解决？")])]),a("li",[a("a",{attrs:{href:"#computed和watch有什么区别"}},[t._v("computed和watch有什么区别")])]),a("li",[a("a",{attrs:{href:"#vue中的-ref-是什么"}},[t._v("vue中的 ref 是什么？")])]),a("li",[a("a",{attrs:{href:"#keep-alive内置组件有什么作用"}},[t._v("keep-alive内置组件有什么作用?")])]),a("li",[a("a",{attrs:{href:"#什么是-nexttick"}},[t._v("什么是$nextTick?")])]),a("li",[a("a",{attrs:{href:"#v-for中key的作用-为什么要加key"}},[t._v("v-for中key的作用，为什么要加key？")])]),a("li",[a("a",{attrs:{href:"#v-model双向绑定是如何实现的"}},[t._v("v-model双向绑定是如何实现的")])]),a("li",[a("a",{attrs:{href:"#vue的响应式原理"}},[t._v("Vue的响应式原理")])]),a("li",[a("a",{attrs:{href:"#vue2数组响应式失效原因"}},[t._v("Vue2数组响应式失效原因")])]),a("li",[a("a",{attrs:{href:"#彻底理解vue2响应式原理"}},[t._v("彻底理解Vue2响应式原理")])]),a("li",[a("a",{attrs:{href:"#vue2组件间通信"}},[t._v("Vue2组件间通信")])]),a("li",[a("a",{attrs:{href:"#mixin和mixins"}},[t._v("mixin和mixins")])]),a("li",[a("a",{attrs:{href:"#vue的编译-渲染过程"}},[t._v("Vue的编译/渲染过程")])]),a("li",[a("a",{attrs:{href:"#父子组件创建销毁过程"}},[t._v("父子组件创建销毁过程")])]),a("li",[a("a",{attrs:{href:"#vue性能优化"}},[t._v("Vue性能优化")])]),a("li",[a("a",{attrs:{href:"#看过vue的源码吗"}},[t._v("看过Vue的源码吗")])]),a("li",[a("a",{attrs:{href:"#vue的diff算法"}},[t._v("Vue的diff算法")])]),a("li",[a("a",{attrs:{href:"#vue3新特性"}},[t._v("Vue3新特性")])]),a("li",[a("a",{attrs:{href:"#vue-router-整理和实现中"}},[t._v("Vue-Router(整理和实现中....)")])]),a("li",[a("a",{attrs:{href:"#说说你对slot的理解-slot使用场景有哪些-整理和实现中"}},[t._v("说说你对slot的理解？slot使用场景有哪些？(整理和实现中....)")])]),a("li",[a("a",{attrs:{href:"#状态管理-整理和实现中"}},[t._v("状态管理(整理和实现中....)")])]),a("li",[a("a",{attrs:{href:"#vue项目封装axios-封装哪方面的"}},[t._v("Vue项目封装axios？封装哪方面的？")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"vue目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue目录结构"}},[t._v("#")]),t._v(" Vue目录结构")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("目录名")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("作用")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("assets")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("放静态资源")])]),t._v(" "),a("tr",[a("td",[t._v("components")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("放组件")])]),t._v(" "),a("tr",[a("td",[t._v("app.vue")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("根组件")])]),t._v(" "),a("tr",[a("td",[t._v("main.js")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("入口文件")])]),t._v(" "),a("tr",[a("td",[t._v("router(可选)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("路由")])]),t._v(" "),a("tr",[a("td",[t._v("store(可选)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("状态管理")])])])]),t._v(" "),a("h2",{attrs:{id:"什么是spa-单页面应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是spa-单页面应用"}},[t._v("#")]),t._v(" 什么是SPA(单页面应用)")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("SPA(Single-Page-Application)")]),a("p",[t._v("单页面应用，就是在页面初始化时，一同加载HTML、CSS、JavaScript，一旦页面加载完成，SPA不会因为用户操作而进行页面跳转和重新加载(例如a标签跳转)，而是采用路由进行组件间的切换，实现html内容的变化。可以给客户更好的用户体验，内容更改无需重新加载页面。")])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("优缺点")]),t._v(" "),a("ul",[a("li",[t._v("优点:\n"),a("ul",[a("li",[t._v("SPA相较于SSR对服务器的压力更小"),a("br")])])]),t._v(" "),a("li",[t._v("缺点:\n"),a("ul",[a("li",[t._v("是首次加载时间过长")]),t._v(" "),a("li",[t._v("不利于SEO")]),t._v(" "),a("li",[t._v("不支持浏览器的前进后退(这个问题被路由解决了)")])])])])]),t._v(" "),a("h2",{attrs:{id:"csr-client-side-rendering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#csr-client-side-rendering"}},[t._v("#")]),t._v(" CSR(Client-Side-Rendering)")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("SPA(Single-Page-Application)")]),a("p",[t._v("客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果(比如ajax请求,浏览器爬虫不会等你请求结果返回后再爬取)，生成相应的 DOM")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("你右键查看源代码,页面上呈现的内容，在源代码文件里是找不到的")]),t._v(" "),a("hr")])]),a("h2",{attrs:{id:"什么是ssr-服务端渲染-优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是ssr-服务端渲染-优缺点"}},[t._v("#")]),t._v(" 什么是SSR(服务端渲染),优缺点?")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("SSR(Server-Side-Rendering)")]),a("p",[t._v("顾名思义是将渲染的工作放在 Server 端进行。服务器渲染"),a("code",[t._v("完整")]),t._v("的HTML后返回给客户端。客户端拿到的内容包括首屏及完整spa结构，应用激活后依然按照spa方式运行。整个过程只向服务端发起一次请求")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("相对的CSR ，客户端渲染，也就是目前 Web 应用中主流的渲染模式，一般由 Server 端返回的初始 HTML 页面，然后再由 JS 去异步加载数据，然后完成页面的渲染")]),t._v("。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("优缺点")]),t._v(" "),a("ul",[a("li",[t._v("优点:\n"),a("ul",[a("li",[t._v("在服务端就返回渲染好的html页面给客户端,有更好的SEO表现")]),t._v(" "),a("li",[t._v("更快的首屏加载速度")])])]),t._v(" "),a("li",[t._v("缺点:\n"),a("ul",[a("li",[t._v("在服务器端渲染,性能开销比较大,占用服务器资源")]),t._v(" "),a("li",[t._v("部署比较麻烦...")])])])])])]),a("h2",{attrs:{id:"vue2生命周期-全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2生命周期-全"}},[t._v("#")]),t._v(" Vue2生命周期(全)")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("生命周期")]),a("p",[t._v("生命周期就是Vue实例从创建到销毁的过程，过程分为八个钩子，分别是"),a("strong",[t._v("创建前后、挂载前后、更新前后、销毁前后")]),t._v("。即"),a("code",[t._v("指从创建、初始化数据、编译模板、挂载到DOM上和渲染、更新到渲染、销毁的一系列过程")]),t._v("。")])]),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("生命周期中比较重要的钩子")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("created()")])]),t._v(" "),a("ul",[a("li",[t._v("这时候数据初始化完成，可以在这里发ajax请求等等。也就是created在组件实例一旦创建完成后就立即调用created()方法，这时候页面dom节点还没生成。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("mounted()")])]),t._v(" "),a("ul",[a("li",[t._v("是在dom节点渲染完成之后立刻调用的，所以可以获取访问数据和dom元素。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("beforeDestory()")])]),t._v(" "),a("ul",[a("li",[t._v("销毁前需要清除定时器清除缓存,防止内存泄漏")])])]),t._v(" "),a("li",[a("p",[t._v("还有Keep-alive带来的三个额外钩子 1.activated 2.deactivated")])]),t._v(" "),a("li",[a("p",[t._v("如果采用Nuxt.js做SSR,"),a("code",[t._v("beforeMounted()")]),t._v("之后的钩子都不会被调用,同时在"),a("code",[t._v("beforeCreate()")]),t._v("之前拓展了许多服务器端执行的钩子.")])])])]),t._v(" "),a("h2",{attrs:{id:"为什么说vue是单向数据流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么说vue是单向数据流"}},[t._v("#")]),t._v(" 为什么说Vue是单向数据流？")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("单向数据流")]),t._v(" "),a("ul",[a("li",[t._v("子组件无权修改父组件传递的数据，防止子组件意外变更父组件的状态，导致数据流向难以理解，所以说Vue是单向数据流。"),a("br")])]),t._v(" "),a("p",[t._v("参考父子组件通信之"),a("strong",[t._v("子组件传值给父组件")]),t._v("，子组件无法直接传值给父组件，需要触发父组件的事件去让父组件自己去修改值的变化。")])]),t._v(" "),a("h2",{attrs:{id:"组件中的data为什么是一个函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件中的data为什么是一个函数"}},[t._v("#")]),t._v(" 组件中的data为什么是一个函数？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("多个组件实例的data是独立的")]),a("ul",[a("li",[t._v("一个组件可能会实例多次,也就是组件复用")]),t._v(" "),a("li",[t._v("对象在栈中存储的都是地址，函数的作用就是属性私有化，保证组件修改自身时不会影响其他复用组件。"),a("strong",[t._v("如果是对象的话，一个组件修改data的值，其他复用组件都会跟着修改")]),t._v("，不方便数据维护。")])])]),a("h2",{attrs:{id:"组件中的data什么时候可以使用对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件中的data什么时候可以使用对象"}},[t._v("#")]),t._v(" 组件中的data什么时候可以使用对象?")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("data使用对象")]),a("ul",[a("li",[t._v("根组件,因为根组件只会实例化一次")]),t._v(" "),a("li",[t._v("组件复用时所有组件实例都会共享 data，如果 data 是对象的话，就会造成一个组件修改 data 以后会影响到其他所有组件，所以需要将 data 写成函数，每次用到就调用一次函数获得新的数据。")])])]),a("h2",{attrs:{id:"v-if和v-show有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-show有什么区别"}},[t._v("#")]),t._v(" v-if和v-show有什么区别？")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("v-if是销毁代码，v-show 则是将代码注释掉")]),t._v(" "),a("hr")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("两者都是控制元素显示和隐藏，v-if是控制元素本身的增加或者删除，而v-show控制的是元素的CSS属性(display:none)")]),t._v("。")])]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("换种问法:为什么在$refs中拿不到v-if的,能拿到v-show的")]),a("ul",[a("li",[a("p",[t._v("也就是说 ，"),a("strong",[t._v("v-if控制的是整个DOM节点的渲染与否")]),t._v("，DOM节点的切换会有更大的性能消耗(重排reflow)，如果频繁切换的话使用v-show，一次切换的话就可以考虑v-if。")])]),t._v(" "),a("li",[a("p",[t._v("v-show相比与v-if的性能优势是在组件的更新阶段,如果仅仅是在初始化阶段,v-if的下性能还有高于v-show,因为v-if只会渲染命中的一个分支,而v-show会渲染2个分支,通过display来控制显示与否")])]),t._v(" "),a("li",[a("p",[t._v("还有一个区别就是"),a("strong",[t._v("v-show由flase变为true的时候不会触发组件的生命周期")]),t._v("，而v-if由false变为true的时候则会触发组件的beforeCreate、created、beforeMount、mounted")])])])]),a("h2",{attrs:{id:"v-if和v-for一起使用会有什么问题-如何解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-for一起使用会有什么问题-如何解决"}},[t._v("#")]),t._v(" v-if和v-for一起使用会有什么问题？如何解决？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("优先级和性能开销大")]),a("ul",[a("li",[a("p",[t._v("性能开销变大，每次渲染都要先循环再进行条件判断，其次是优先级的问题，Vue2中v-for优先级比v-if高，Vue3中v-if比v-for高。")])]),t._v(" "),a("li",[a("p",[t._v("解决的办法之一是采用计算属性替代，先在计算属性里面对数据做一个筛选，然后直接for循环筛选后的数据，就不需要if进行判断了。")])])])]),a("h2",{attrs:{id:"computed和watch有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch有什么区别"}},[t._v("#")]),t._v(" computed和watch有什么区别")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("blockquote",[a("p",[a("strong",[t._v("computed和watch本质都是通过实例化Watcher实现，最大区别就是使用场景不同")]),t._v("。")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("computed也就是计算属性，"),a("strong",[t._v("依赖其他值且值具备缓存的特性，只有它依赖的值发送发生改变，下一次获取的值才会重新计算")]),t._v("，适用于复杂的数值计算并且依赖于其他属性时，就可以利用缓存特性，避免每次获取值都需要重新计算。")])]),t._v(" "),a("li",[a("p",[t._v("watch侦听器，"),a("strong",[t._v("监听属性值的变化，每当属性值发送变化，都会执行相应的回调函数")]),t._v("。适用于数据变化时执行异步或者开销比较大的操作")])])])]),a("h2",{attrs:{id:"vue中的-ref-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中的-ref-是什么"}},[t._v("#")]),t._v(" vue中的 ref 是什么？")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上")]),t._v("。")])]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("ref")]),a("ul",[a("li",[t._v("如果在普通的 DOM 元素上使用，"),a("strong",[t._v("引用指向的就是 DOM 元素")]),t._v("；")]),t._v(" "),a("li",[t._v("如果用在子组件上，"),a("strong",[t._v("引用就指向组件实例")]),t._v("。")])])]),a("h2",{attrs:{id:"keep-alive内置组件有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive内置组件有什么作用"}},[t._v("#")]),t._v(" keep-alive内置组件有什么作用?")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("keep-alive")]),a("ul",[a("li",[a("strong",[t._v("当进行组件的切换的时候,如果需要保持原组件的状态,则可以使用"),a("code",[t._v("keep-alive")]),t._v("包裹要缓存的组件")])]),t._v(" "),a("li",[a("strong",[t._v("keep-alive有两个独有的生命周期钩子 1.actived 2.deactivated")])]),t._v(" "),a("li",[a("strong",[t._v("用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数")])])])]),a("h2",{attrs:{id:"什么是-nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-nexttick"}},[t._v("#")]),t._v(" 什么是$nextTick?")]),t._v(" "),a("blockquote",[a("p",[t._v("一"),a("strong",[t._v("次完整的DOM更新称为Tick，nextTick也就是在下次DOM更新循环j结束之后执行延迟回调，常用于修改数据后获取更新后的DOM")]),t._v("。")])]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("$nextTick")]),a("p",[t._v("其实就是运用异步锁的的概念，保证同一时刻任务队列只有一个flushCallbacks，当pending为false的时候，表示浏览器任务队列中没有flushCallbacks函数，当pending为true的时候，表示浏览器任务队列中已经放入flushCallbacks，待执行flushCallbacks函数时，pending为被再次置位false，表示下一个flushCallbacks可进入任务队列，环境能力检测选择可选中效率最高的(宏任务/微任务)进行包装执行，保证是在同步代码都执行完成后，再去执行修改DOM等操作，flushcallbacks先拷贝再清空，为了防止nextTick嵌套mextTick导致循环不结束")]),t._v(" "),a("p",[t._v("源码: vue/src/core/util/next-tick.js")]),t._v(" "),a("p",[t._v("Tick是一次数据渲染的周期，nextTick就是指渲染后执行")]),t._v(" "),a("ul",[a("li",[t._v("*"),a("code",[t._v("$nextTick")]),t._v("是什么？vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。"),a("code",[t._v("$nextTick")]),t._v(" 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM")])])]),a("h2",{attrs:{id:"v-for中key的作用-为什么要加key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-for中key的作用-为什么要加key"}},[t._v("#")]),t._v(" v-for中key的作用，为什么要加key？")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("v-for中key的作用")]),a("ol",[a("li",[a("p",[t._v("key是Vue中Vnode的唯一标记，diff算法中，sameVnode和updateChildren中就使用了key。sameVnode用来判断是否为同一节点，常见的业务常见是一个列表，若key值是列表索引，在新增或删除的情况下就会存在"),a("strong",[t._v("就地复用")]),t._v("的问题(就是复用了上一个在当前位置元素的状态)。所以key值的唯一确保diff更准确。")])]),t._v(" "),a("li",[a("p",[t._v("updateChildren保证新开老开是同一节点，新开老结是同一节点，老开新结是同一节点，老结新开是同一节点。如果都未匹配，就需要依赖老节点的key和索引创建关系映射表，再用新节点的key去关系映射表，再用新节点的key去关系映射表，去寻找索引进行更新。这保证diff算法快速而准确")])])])]),a("h2",{attrs:{id:"v-model双向绑定是如何实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-model双向绑定是如何实现的"}},[t._v("#")]),t._v(" v-model双向绑定是如何实现的")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("v-model双向绑定")]),a("blockquote",[a("p",[t._v("v-model指令用于实现input、select等表单元素的双向绑定，实际上是@input和value的语法糖。")])]),t._v(" "),a("ul",[a("li",[t._v("原生input元素若是text/textarea类型，使用value属性和input事件。")]),t._v(" "),a("li",[t._v("原生input元素若是radio/checkbox类型，使用checked属性和change事件。")]),t._v(" "),a("li",[t._v("原生select元素，使用value属性和change事件。")])]),t._v(" "),a("p",[a("strong",[t._v("input元素上使用v-mode等价于")])]),t._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("input")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":value")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("messgae"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("@input")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("message = $event.target.value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])]),a("h2",{attrs:{id:"vue的响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的响应式原理"}},[t._v("#")]),t._v(" Vue的响应式原理")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("三个步骤")]),a("ul",[a("li",[t._v("数据劫持")]),t._v(" "),a("li",[t._v("收集依赖")]),t._v(" "),a("li",[t._v("派发更新")])]),t._v(" "),a("p",[a("strong",[t._v("数据分为两类，数组和对象")]),t._v("。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当遍历对象的时候，通过Object.defineProperty为每个属性添加getter和setter进行数据劫持，getter函数用于在数据读取时进行收集依赖，在对应的dep中存储所有的watcher，setter则是在数据更新后通知所有的watcher进行更新")])]),t._v(" "),a("li",[a("p",[t._v("当遍历数组的时候，用数组增强的方式，覆盖原属性上默认的数组方法，保证在新增或删除数据时，通过dep通知所有的watcher进行更新")])]),t._v(" "),a("li",[a("p",[t._v("运用观察者模式或者发布-订阅模式，当一个对象被修改时会自动通知依赖它的对象")])])])]),a("details",{staticClass:"custom-block details"},[a("summary",[t._v("响应式源码")]),t._v(" "),a("blockquote",[a("p",[t._v("响应式更新对象的源码下图")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" defineReactive"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    xxxx快了快了"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("blockquote",[a("p",[t._v("响应式更新数组源码如下图")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" defineReactive"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    xxxx快了快了"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("blockquote",[a("p",[t._v("观察者模式和发布订阅模式")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" defineReactive"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    xxxx快了快了"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])])]),t._v(" "),a("h2",{attrs:{id:"vue2数组响应式失效原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2数组响应式失效原因"}},[t._v("#")]),t._v(" Vue2数组响应式失效原因")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("vue引用类型响应式失效")]),a("blockquote",[a("p",[a("strong",[t._v("JavaScript 的限制，Vue 不能检测数组和对象的变化")])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("数组")]),t._v(" "),a("ul",[a("li",[t._v("Vue2改写了数组的7个方法,"),a("code",[t._v("'push','pop','shift','unshift','splice','sort','reverse'")])]),t._v(" "),a("li",[t._v("这7个方法是可以检测到变化的.")]),t._v(" "),a("li",[a("strong",[t._v("但是使用索引赋值或者改变数组的长度,响应式是会失效")])])])]),t._v(" "),a("li",[a("p",[t._v("对象")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Vue2无法检测对象属性的增加或者删除")]),t._v(",这是因为Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property "),a("strong",[t._v("必须在 data 对象上存在才能让 Vue 将它转换为响应式的")]),t._v("。")]),t._v(" "),a("li",[t._v("这个问题仅存在于Vue2.x,"),a("strong",[t._v("因为Vue3使用了Proxy直接劫持整个对象,而不是对象的属性")]),t._v(",所以不存在这个问题")])])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("解决方法")]),t._v(" "),a("ul",[a("li",[t._v("如果是数组, 增添元素可以使用改写过后的splice()方法,或者下面的Vue.set()方法")]),t._v(" "),a("li",[t._v("如果是对象, 使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上。 还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名。")])]),t._v(" "),a("div",{staticClass:"language-tsx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-tsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//[empty,2,3,4]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//[2,3,4]")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])])])]),a("h2",{attrs:{id:"彻底理解vue2响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#彻底理解vue2响应式原理"}},[t._v("#")]),t._v(" 彻底理解Vue2响应式原理")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("ol",[a("li",[a("p",[t._v("vue会遍历此data中对象的所有属性")])]),t._v(" "),a("li",[a("p",[t._v("并使用Object.defineProperty把这些属性全部转为getter/setter")])]),t._v(" "),a("li",[a("p",[t._v("每个组件实例都有watcher对象")])]),t._v(" "),a("li",[a("p",[t._v("它会在组件渲染的过程中吧属性记录为依赖")])]),t._v(" "),a("li",[a("p",[t._v("之后当依赖项的setter被调用时，会通知watcher重新计算，从而使它关联的组件得以更新")])])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("三个最重要的对象")])])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Observer、Watcher、Dep")])])]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("Observer对象: vue中的数据对象在初始化过程中转换为Observer对象")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Watcher对象: 将模板和Observer对象结合在一起生成watcher实例，Watcher是订阅者中的订阅者。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Dep对象: Watcher对象和Observer对象之间纽带，每一个Observer都有一个Dep实例，用来存储订阅者Watcher")])])])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("当属性变化会执行主体对象Observer的dep.notify()方法")]),t._v("，这个方法会遍历订阅者Watcher列表向其发送信息，Watcher会执行run方法去更新视图。模板编译过程中的指令和数据绑定都会生成watcher实例，实例中的watch属性也会生成Watcher实例")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("在生命周期的initState方法中将data，prop，method,computed, watch中的数据劫持，通过observe方法与Object.defineProperty方法将相关对象转为换Observer对象")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("然后在initRender方法中解析模板，通过Watcher对象，Dep对象与观察者模式将模板中的指令与对象的数据建立依赖关系，"),a("strong",[t._v("使用全局对象Dep.target实现依赖收集")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("当数据变化时，setter被调用，"),a("strong",[t._v("触发Object.defineProperty方法中的dep.notify方法")]),t._v("，遍历该数据依赖列表，执行器update方法通知Watcher进行视图更新。")])])])]),a("h2",{attrs:{id:"vue2组件间通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2组件间通信"}},[t._v("#")]),t._v(" Vue2组件间通信")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("如果组件A引入了B,那么A就是B的父亲,同级则是兄弟")]),a("ul",[a("li",[t._v("父传子: props")]),t._v(" "),a("li",[t._v("子传父: $emit")]),t._v(" "),a("li",[t._v("事件总线: EventBus: $emit,$on,")]),t._v(" "),a("li",[t._v("VueX")]),t._v(" "),a("li",[t._v("provide/inject")]),t._v(" "),a("li",[t._v("$parent/$children")]),t._v(" "),a("li",[t._v("$attrs/$listeners")]),t._v(" "),a("li",[t._v("ref")])])]),a("details",{staticClass:"custom-block details"},[a("summary",[t._v("Vue2组件间通信代码")]),t._v(" "),a("p",[t._v("有空补充...")])]),t._v(" "),a("h2",{attrs:{id:"mixin和mixins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mixin和mixins"}},[t._v("#")]),t._v(" mixin和mixins")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("mixin")]),a("blockquote",[a("p",[t._v("混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项")])]),t._v(" "),a("ul",[a("li",[t._v("其实就是把共用的代码抽出来,不用每个组件都写一遍,复用代码逻辑")]),t._v(" "),a("li",[t._v("mixin 用于全局混入，会影响到每个组件实例，会看到插件是这么做初始化的")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("Vue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mixin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("beforeCreate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...逻辑")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这种方式会影响到每个组件的 beforeCreate 钩子函数")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("mixins")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。")])]),t._v(" "),a("li",[a("p",[t._v("另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，如果组件内有同名方法,会覆盖mixin中的方法")])])])])]),a("h2",{attrs:{id:"vue的编译-渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的编译-渲染过程"}},[t._v("#")]),t._v(" Vue的编译/渲染过程")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("Vue的编译/渲染过程")]),a("p",[t._v("浏览器只能解析html文档,Vue模板显然需要通过编译才能在浏览器中运行渲染.")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("将模板解析为 AST")])]),t._v(" "),a("li",[a("strong",[t._v("优化 AST(节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。)")])]),t._v(" "),a("li",[a("strong",[t._v("将 AST 转换为 render 函数")])])])]),a("h2",{attrs:{id:"父子组件创建销毁过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父子组件创建销毁过程"}},[t._v("#")]),t._v(" 父子组件创建销毁过程")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("THEOREM")]),a("p",[t._v("先创建父组件,在父组件挂载前,创建并挂载子组件,在父组件销毁前,销毁子组件")])]),a("h2",{attrs:{id:"vue性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue性能优化"}},[t._v("#")]),t._v(" Vue性能优化")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("Vue性能优化")]),a("p",[t._v("参考文章"),a("a",{attrs:{href:"https://juejin.cn/post/6922641008106668045",target:"_blank",rel:"noopener noreferrer"}},[t._v("揭秘 Vue.js 九个性能优化技巧"),a("OutboundLink")],1)]),t._v(" "),a("ul",[a("li",[t._v("keep-alive 缓存组件,避免重新渲染组件的性能开销")]),t._v(" "),a("li",[t._v("Virtual scrolling 虚拟滚动组件")]),t._v(" "),a("li",[t._v("UI库按需引入")]),t._v(" "),a("li",[t._v("cdn存放静态资源")]),t._v(" "),a("li",[t._v("不必要的响应式数据")]),t._v(" "),a("li",[t._v("用 v-show 复用 DOM")]),t._v(" "),a("li",[t._v("组件的异步加载（按需加载组件）")]),t._v(" "),a("li",[t._v("组件细分,当数据变更时，由于组件代码比较庞大，vue 的数据驱动视图更新会比较慢，造成渲染过慢,用户体验也不好,所以需要将大组件拆分成小组件")])])]),a("h2",{attrs:{id:"看过vue的源码吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#看过vue的源码吗"}},[t._v("#")]),t._v(" 看过Vue的源码吗")]),t._v(" "),a("div",{staticClass:"theorem"},[a("p",{staticClass:"title"},[t._v("Vue的源码")]),a("ul",[a("li",[t._v("实际上这个回答的重点，并不是你看过什么源码，而是看你怎么看源码的。\n因为工作原因，我看过XXXX的源码，分析过里面的功能，但是只看功能是第一步的，我原先总结的看代码目标是：")])]),t._v(" "),a("ul",[a("li",[t._v("自动机中功能性的划分，能迅速找到功能划分的位置。")]),t._v(" "),a("li",[t._v("针对某些异常情况的处理，能迅速找到在不同步骤出异常或问题时的处理流程。")]),t._v(" "),a("li",[t._v("系统竞争和瓶颈所在地，能迅速找到可能导致并发 /新建问题出现的地方。")]),t._v(" "),a("li",[t._v("多线程或多进程同步的地方，能迅速分析清楚具体是哪种同步模型。")]),t._v(" "),a("li",[t._v("能够将模块中可拆分 /变化的部分迅速找到，并零件化")])])]),a("h2",{attrs:{id:"vue的diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的diff算法"}},[t._v("#")]),t._v(" Vue的diff算法")]),t._v(" "),a("ul",[a("li",[t._v("不优化的virtual Dom算法,就是新旧模板进行完整的比对,每次更新都是全量更新")]),t._v(" "),a("li",[t._v("而优化后的则是 对模板的编译时优化生成 render function")]),t._v(" "),a("li",[t._v("vue 3 静态节点 动态节点  patch flag  带patch flag的节点才会被真正追踪 就是更新的时候只会跟踪 "),a("strong",[t._v("真正会变的东西")])]),t._v(" "),a("li",[t._v("v-for循环加key,  key可以唯一标识一个循环个体，可以使用例如 item.id 作为 key。\n在列表数据进行遍历渲染时，给每一项item设置唯一key值，会方便vue内部机制精准找到该条列表数据。当state更新时，新的状态值和旧的状态值对比，较快地定位到diff")])]),t._v(" "),a("h2",{attrs:{id:"vue3新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3新特性"}},[t._v("#")]),t._v(" Vue3新特性")]),t._v(" "),a("ul",[a("li",[t._v("webpack/rollup 都有tree shaking的功能，但前提是你用esmodule Import去写")]),t._v(" "),a("li",[t._v("teleport 对标 react的"),a("code",[t._v("<Portal>")])]),t._v(" "),a("li",[t._v("suspense 管理嵌套组件的异步加载")]),t._v(" "),a("li",[t._v("import就会真正地发请求  vite就会拦截这个请求 返回JS 就不需要重新打包")])]),t._v(" "),a("h2",{attrs:{id:"vue-router-整理和实现中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-整理和实现中"}},[t._v("#")]),t._v(" Vue-Router(整理和实现中....)")]),t._v(" "),a("h2",{attrs:{id:"说说你对slot的理解-slot使用场景有哪些-整理和实现中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说你对slot的理解-slot使用场景有哪些-整理和实现中"}},[t._v("#")]),t._v(" 说说你对slot的理解？slot使用场景有哪些？(整理和实现中....)")]),t._v(" "),a("h2",{attrs:{id:"状态管理-整理和实现中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态管理-整理和实现中"}},[t._v("#")]),t._v(" 状态管理(整理和实现中....)")]),t._v(" "),a("h2",{attrs:{id:"vue项目封装axios-封装哪方面的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue项目封装axios-封装哪方面的"}},[t._v("#")]),t._v(" Vue项目封装axios？封装哪方面的？")])])}),[],!1,null,null,null);s.default=v.exports}}]);