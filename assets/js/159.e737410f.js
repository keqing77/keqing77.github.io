(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{754:function(t,e,v){"use strict";v.r(e);var i=v(14),s=Object(i.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"vite"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[t._v("#")]),t._v(" Vite")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("打包快如闪电!")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("开发下使用esbuild(Go编写的构建工具)")])]),t._v(" "),v("li",[v("strong",[t._v("生产环境下使用rollup(Svelte作者用JS写的一个打包工具)")])])])]),t._v(" "),v("h2",{attrs:{id:"为什么选择vite"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么选择vite"}},[t._v("#")]),t._v(" 为什么选择Vite？")]),t._v(" "),v("p",[t._v("因为使用Vite构建项目比webpack快得多！！！打包快如闪电！")]),t._v(" "),v("h2",{attrs:{id:"vite快的原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vite快的原因"}},[t._v("#")]),t._v(" Vite快的原因")]),t._v(" "),v("blockquote",[v("p",[t._v("浏览器之前是不支持ES Modules的，就是通过import，export来导入导出模块，所以需要借助类似webpack的打包工具，")])]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("之前的构建方案(webpack)")]),v("ul",[v("li",[t._v("比如要引入A.js,B.js,C.js, 如果是webpack,则会将这三个js文件打包在一个bundle.js文件里,再引入这个打包后的文件.")]),t._v(" "),v("li",[t._v("这带来的问题就是项目越来越大，启动项目的时间非常长,可能要几分钟(实际上是修改1行代码都要几分钟😅)")])])]),v("ul",[v("li",[t._v("vite 主要对应的场景是开发模式，它只启动一台静态页面的服务器，对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理")]),t._v(" "),v("li",[t._v("vite 项目启动时，将模块分成依赖和源码，当你更新代码时，依赖就不需要重新加载，只需要精准地找到是哪个源码的文件更新了，更新相对应的文件就行了。同时vite对于node_modules的文件做了强缓存(也就是依赖)，而对我们编写的源码做了协商缓存")]),t._v(" "),v("li",[t._v("vite一个问题就是开发环境和生产环境的行为不一致,esbuild兼容性还待提升,不是每个浏览器都支持的")])]),t._v(" "),v("h2",{attrs:{id:"冷启动和热更新时候webpack和vite的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#冷启动和热更新时候webpack和vite的区别"}},[t._v("#")]),t._v(" 冷启动和热更新时候webpack和vite的区别")]),t._v(" "),v("blockquote",[v("p",[t._v("冷启动webpack做了什么")])]),t._v(" "),v("p",[t._v("webpack的热更新就是，当我们对代码做修改并保存后，webpack会对修改的代码块进行重新打包，并将新的模块发送至浏览器端，浏览器用新的模块代替旧的模块，从而实现了在不刷新浏览器的前提下更新页面。相比起直接刷新页面的方案，HMR的优点是可以保存应用的状态。"),v("strong",[t._v("但是，随着项目体积的增长，热更新的速度也会随之下降。")])]),t._v(" "),v("h2",{attrs:{id:"vite热更新的实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vite热更新的实现原理"}},[t._v("#")]),t._v(" Vite热更新的实现原理")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("vite对于热更新的实现，")]),v("p",[t._v("大致可以分为三步：")]),t._v(" "),v("ol",[v("li",[t._v("监听文件变动")]),t._v(" "),v("li",[t._v("读取文件内容")]),t._v(" "),v("li",[t._v("通知浏览器做相应的更新")])])]),v("ul",[v("li",[v("p",[t._v("创建一个websocket服务端。vite执行createWebSocketServer函数，调用ws库创建ws服务端。")])]),t._v(" "),v("li",[v("p",[t._v("创建一个ws客户端来接收ws服务端的信息。vite首先会创建一个ws client文件，然后在处理入口文件index.html时，把对ws client文件的引入注入到index.html文件中。当浏览器访问index.html时，就会加载ws client文件并执行，创建一个客户端ws，从而接收ws服务端的信息。")])]),t._v(" "),v("li",[v("p",[t._v("服务端监听文件变化，发送websocket消息，通知客户端。")])]),t._v(" "),v("li",[v("p",[t._v("服务端调用handleHMRUpdate函数，该函数会根据此次修改文件的类型，通知客户端是要刷新还是重新加载文件。")])]),t._v(" "),v("li",[v("p",[t._v("vite对于node_modules的文件(也就是依赖)做了强缓存，而编写的代码做了协商缓存")])])]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("构建速度快")]),t._v("：\n"),v("ul",[v("li",[t._v("Webpack 会先将代码打包，然后启动开发服务器，请求服务器时返回打包后的结果；而 Vite 是直接启动开发服务器，请求哪个模块再对该模块进行实时编译，省去了打包的过程。")])])]),t._v(" "),v("li",[v("strong",[t._v("热更新快")]),t._v("：\n"),v("ul",[v("li",[t._v("相比起webpack，vite会让浏览器帮忙做更多的事情。vite 采用立即编译当前修改文件的办法，当改动了一个模块后，仅需让浏览器重新请求该模块即可。同时 vite 还会使用缓存机制( http 缓存、 vite 内置缓存 )，加载更新后的文件内容。")])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);